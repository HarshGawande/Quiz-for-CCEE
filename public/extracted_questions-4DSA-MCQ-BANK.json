[
  {
    "id": 1,
    "topic": "General",
    "question": "ALGORITHMS AND DATA STRUCTURE USING JAVA MCQ BANK Total No. Of MCQs : 620 Name : Shubham Shivaji Patil Lecture 1: Problem Solving & Computational Thinking **1.1 Define the problem** 1. What is the primary purpose of \"defining the problem\" in problem-solving?",
    "options": [
      "To ignore the problem",
      "To identify multiple problems",
      "To understand the underlying issues and requirements",
      "To guess a solution"
    ],
    "answer": "To understand the underlying issues and requirements"
  },
  {
    "id": 2,
    "topic": "General",
    "question": "2. When should you define the problem during the problem-solving process?",
    "options": [
      "At the end",
      "After finding a solution",
      "After identifying the problem",
      "At the beginning"
    ],
    "answer": "At the beginning"
  },
  {
    "id": 3,
    "topic": "General",
    "question": "3. What does \"scope\" refer to when defining a problem?",
    "options": [
      "The difficulty level of the problem",
      "The timeline for solving the problem",
      "The specific elements and boundaries of the problem",
      "The financial cost of solving the problem"
    ],
    "answer": "The specific elements and boundaries of the problem"
  },
  {
    "id": 4,
    "topic": "General",
    "question": "4. Which of the following statements is true?",
    "options": [
      "A well-defined problem has only one possible solution",
      "A well-defined problem has multiple possible solutions",
      "A well-defined problem has no solution",
      "Problem definition is not essential in problem-solving"
    ],
    "answer": "A well-defined problem has multiple possible solutions"
  },
  {
    "id": 5,
    "topic": "General",
    "question": "5. What is the first step in the process of defining a problem?",
    "options": [
      "Listing possible solutions",
      "Identifying the problem",
      "Recognizing the symptoms of the problem",
      "Analyzing the consequences of the problem"
    ],
    "answer": "Identifying the problem"
  },
  {
    "id": 6,
    "topic": "General",
    "question": "6. How can defining the problem accurately help in problem-solving?",
    "options": [
      "It narrows down the scope of the problem",
      "It guarantees finding the correct solution",
      "It makes the problem more challenging",
      "It is not relevant to problem-solving"
    ],
    "answer": "It narrows down the scope of the problem"
  },
  {
    "id": 7,
    "topic": "General",
    "question": "7. What is the significance of understanding the problem before attempting to solve it?",
    "options": [
      "It reduces the chances of finding a solution",
      "It helps in finding irrelevant solutions",
      "It ensures the problem is ignored",
      "It ensures a more focused and effective problem-solving process"
    ],
    "answer": "It ensures a more focused and effective problem-solving process"
  },
  {
    "id": 8,
    "topic": "General",
    "question": "8. Which of the following is NOT a benefit of defining the problem accurately?",
    "options": [
      "Saves time and resources",
      "Avoids the need for problem-solving",
      "Increases the chances of finding a suitable solution",
      "Helps in setting clear objectives"
    ],
    "answer": "Avoids the need for problem-solving"
  },
  {
    "id": 9,
    "topic": "General",
    "question": "9. How does problem definition contribute to effective communication in problem-solving?",
    "options": [
      "It hinders communication among team members",
      "It creates confusion and misunderstanding",
      "It establishes a common understanding among stakeholders",
      "It is not relevant to communication"
    ],
    "answer": "It establishes a common understanding among stakeholders"
  },
  {
    "id": 10,
    "topic": "General",
    "question": "10. What happens if the problem is not properly defined in the problem-solving process?",
    "options": [
      "It guarantees finding the best solution",
      "It reduces the likelihood of finding a solution",
      "It eliminates the need for finding a solution",
      "It helps in finding all possible solutions"
    ],
    "answer": "It reduces the likelihood of finding a solution"
  },
  {
    "id": 11,
    "topic": "General",
    "question": "**1.2 Identify the problem** 1. What is the primary goal of \"identifying the problem\" in problem-solving?",
    "options": [
      "Finding a solution immediately",
      "Understanding the context and nature of the problem",
      "Ignoring the problem",
      "Avoiding the problem"
    ],
    "answer": "Understanding the context and nature of the problem"
  },
  {
    "id": 12,
    "topic": "General",
    "question": "2. How is \"identifying the problem\" different from \"defining the problem\"?",
    "options": [
      "They are the same",
      "Identifying the problem comes after defining the problem",
      "Defining the problem comes after identifying the problem",
      "They are not related to problem-solving"
    ],
    "answer": "Defining the problem comes after identifying the problem"
  },
  {
    "id": 13,
    "topic": "General",
    "question": "3. When should you identify the problem during the problem-solving process?",
    "options": [
      "At the beginning",
      "At the end",
      "Somewhere in the middle",
      "It is not necessary to identify the problem"
    ],
    "answer": "At the beginning"
  },
  {
    "id": 14,
    "topic": "General",
    "question": "4. What is the first step in the process of identifying a problem?",
    "options": [
      "Listing possible solutions",
      "Analyzing the consequences of the problem",
      "Recognizing and acknowledging the existence of the problem",
      "Assuming there is no problem"
    ],
    "answer": "Recognizing and acknowledging the existence of the problem"
  },
  {
    "id": 15,
    "topic": "General",
    "question": "5. How can problem identification help in the problem-solving process?",
    "options": [
      "It guarantees finding the correct solution",
      "It makes the problem more complicated",
      "It helps in defining the scope of the problem",
      "It is not relevant to problem-solving"
    ],
    "answer": "It helps in defining the scope of the problem"
  },
  {
    "id": 16,
    "topic": "General",
    "question": "6. What does \"identifying the problem\" involve?",
    "options": [
      "Guessing the solution",
      "Focusing only on the symptoms of the problem",
      "Analyzing the consequences of the problem",
      "Recognizing the underlying causes of the problem"
    ],
    "answer": "Recognizing the underlying causes of the problem"
  },
  {
    "id": 17,
    "topic": "General",
    "question": "7. Why is it essential to identify the problem accurately?",
    "options": [
      "It guarantees finding the best solution",
      "It helps in avoiding the problem",
      "It reduces the chances of finding a solution",
      "It helps in finding an appropriate solution"
    ],
    "answer": "It helps in finding an appropriate solution"
  },
  {
    "id": 18,
    "topic": "General",
    "question": "8. What is the significance of understanding the problem before attempting to solve it?",
    "options": [
      "It reduces the chances of finding a solution",
      "It helps in finding irrelevant solutions",
      "It ensures the problem is ignored",
      "It ensures a more focused and effective problem-solving process"
    ],
    "answer": "It ensures a more focused and effective problem-solving process"
  },
  {
    "id": 19,
    "topic": "General",
    "question": "9. How does problem identification contribute to effective communication in problem-solving?",
    "options": [
      "It hinders communication among team members",
      "It creates confusion and misunderstanding",
      "It establishes a common understanding among stakeholders",
      "It is not relevant to communication"
    ],
    "answer": "It establishes a common understanding among stakeholders"
  },
  {
    "id": 20,
    "topic": "General",
    "question": "10. What happens if the problem is not properly identified in the problem-solving process?",
    "options": [
      "It guarantees finding the best solution",
      "It reduces the likelihood of finding a solution",
      "It eliminates the need for finding a solution",
      "It helps in finding all possible solutions"
    ],
    "answer": "It reduces the likelihood of finding a solution"
  },
  {
    "id": 21,
    "topic": "General",
    "question": "**1.3 Introduction to Problem Solving** 1. What is problem-solving?",
    "options": [
      "Avoiding problems",
      "Finding multiple solutions to a problem",
      "Analyzing the consequences of a problem",
      "Process of finding solutions to difficult or complex issues"
    ],
    "answer": "Process of finding solutions to difficult or complex issues"
  },
  {
    "id": 22,
    "topic": "General",
    "question": "2. Which of the following is NOT a characteristic of effective problem-solving?",
    "options": [
      "Relying solely on intuition without analysis",
      "Systematic and logical approach to finding solutions",
      "Ignoring the problem-solving process",
      "Understanding the problem and gathering relevant information"
    ],
    "answer": "Ignoring the problem-solving process"
  },
  {
    "id": 23,
    "topic": "General",
    "question": "3. How can problem-solving be helpful beyond finding solutions?",
    "options": [
      "Creating new problems",
      "Defining new problems",
      "Generating new challenges",
      "Understanding the problem, analyzing it, and making decisions"
    ],
    "answer": "Understanding the problem, analyzing it, and making decisions"
  },
  {
    "id": 24,
    "topic": "General",
    "question": "4. What is the first step in the problem-solving process?",
    "options": [
      "Implementing the solution",
      "Identifying the problem",
      "Defining the problem",
      "Evaluating the outcome"
    ],
    "answer": "Identifying the problem"
  },
  {
    "id": 25,
    "topic": "General",
    "question": "5. What are the benefits of effective problem-solving skills?",
    "options": [
      "Solving every problem instantly",
      "Avoiding challenges altogether",
      "Improved decision-making, creativity, and efficiency",
      "Ignoring problems and hoping they disappear"
    ],
    "answer": "Improved decision-making, creativity, and efficiency"
  },
  {
    "id": 26,
    "topic": "General",
    "question": "6. How can creativity be helpful in problem-solving?",
    "options": [
      "It hinders the problem-solving process",
      "It brings new perspectives and ideas to find innovative solutions",
      "Creativity has no impact on problem-solving",
      "It leads to irrelevant solutions"
    ],
    "answer": "It brings new perspectives and ideas to find innovative solutions"
  },
  {
    "id": 27,
    "topic": "General",
    "question": "7. Why is it essential to evaluate the outcome of a problem-solving process?",
    "options": [
      "To ignore the effectiveness of the solution",
      "To determine if the problem was challenging enough",
      "To identify areas of improvement and learn from the experience",
      "To guarantee that the problem will not reoccur"
    ],
    "answer": "To identify areas of improvement and learn from the experience"
  },
  {
    "id": 28,
    "topic": "General",
    "question": "8. What does \"thinking outside the box\" mean in problem-solving?",
    "options": [
      "Limiting yourself to traditional solutions",
      "Relying solely on intuition",
      "Expanding possibilities and considering unconventional approaches",
      "Sticking to the most straightforward solution"
    ],
    "answer": "Expanding possibilities and considering unconventional approaches"
  },
  {
    "id": 29,
    "topic": "General",
    "question": "9. How can problem-solving skills be beneficial in various aspects of life?",
    "options": [
      "They are only applicable in academic settings",
      "They can only be used in specific professions",
      "They are essential in decision-making, work, and personal life",
      "Problem-solving skills have no practical applications"
    ],
    "answer": "They are essential in decision-making, work, and personal life"
  },
  {
    "id": 30,
    "topic": "General",
    "question": "10. What happens if problem-solving skills are not honed or practiced regularly?",
    "options": [
      "It ensures immediate success in solving all problems",
      "It makes problems more difficult to solve",
      "It eliminates the need for problem-solving",
      "It reduces the effectiveness of finding solutions"
    ],
    "answer": "It reduces the effectiveness of finding solutions"
  },
  {
    "id": 31,
    "topic": "General",
    "question": "**1.4 Problem-solving basics** 1. What does problem-solving involve besides finding solutions?",
    "options": [
      "Identifying new problems",
      "Implementing the most complex solution",
      "Evaluating the outcome",
      "Avoiding the problem"
    ],
    "answer": "Evaluating the outcome"
  },
  {
    "id": 32,
    "topic": "General",
    "question": "2. How can problem-solving contribute to personal growth and development?",
    "options": [
      "It prevents individuals from learning from their experiences",
      "It discourages creativity and critical thinking",
      "It helps individuals become more efficient and adaptable",
      "It guarantees that individuals never encounter challenges"
    ],
    "answer": "It helps individuals become more efficient and adaptable"
  },
  {
    "id": 33,
    "topic": "General",
    "question": "3. What is the role of critical thinking in problem-solving?",
    "options": [
      "It hinders the problem-solving process",
      "It limits the exploration of possible solutions",
      "It enhances decision-making and solution evaluation",
      "Critical thinking is irrelevant to problem-solving"
    ],
    "answer": "It enhances decision-making and solution evaluation"
  },
  {
    "id": 34,
    "topic": "General",
    "question": "4. Why is it important to approach problem-solving systematically?",
    "options": [
      "It slows down the problem-solving process",
      "It guarantees finding the correct solution",
      "It increases the chances of overlooking possible solutions",
      "It ensures a structured and organized approach to finding solutions"
    ],
    "answer": "It ensures a structured and organized approach to finding solutions"
  },
  {
    "id": 35,
    "topic": "General",
    "question": "5. What is the significance of collaboration in problem-solving?",
    "options": [
      "It increases competition and rivalry among team members",
      "It leads to conflicts and delays in finding solutions",
      "It fosters diverse perspectives and creative problem-solving",
      "Collaboration has no impact on problem-solving"
    ],
    "answer": "It fosters diverse perspectives and creative problem-solving"
  },
  {
    "id": 36,
    "topic": "General",
    "question": "6. How can effective problem-solving skills be beneficial in professional settings?",
    "options": [
      "They are irrelevant in the workplace",
      "They improve teamwork and productivity",
      "They guarantee immediate promotions",
      "They only apply to specific professions"
    ],
    "answer": "They improve teamwork and productivity"
  },
  {
    "id": 37,
    "topic": "General",
    "question": "7. Which of the following is NOT a characteristic of successful problem solvers?",
    "options": [
      "Adaptability and openness to change",
      "Relying solely on intuition and assumptions",
      "Willingness to seek help and collaborate with others",
      "Persistence and determination"
    ],
    "answer": "Relying solely on intuition and assumptions"
  },
  {
    "id": 38,
    "topic": "General",
    "question": "8. How can effective problem-solving positively impact decision-making?",
    "options": [
      "It guarantees perfect decision-making",
      "It reduces the need for decision-making",
      "It enhances the quality of decision-making through better evaluation of alternatives",
      "Decision-making is irrelevant to problem-solving"
    ],
    "answer": "It enhances the quality of decision-making through better evaluation of alternatives"
  },
  {
    "id": 39,
    "topic": "General",
    "question": "9. Which of the following statements is true?",
    "options": [
      "Effective problem-solving skills can only be learned in academic settings",
      "Problem-solving is limited to specific professions",
      "Problem-solving skills are transferable and applicable in various situations",
      "Problem-solving has no relevance beyond finding solutions"
    ],
    "answer": "Problem-solving skills are transferable and applicable in various situations"
  },
  {
    "id": 40,
    "topic": "General",
    "question": "10. How does problem-solving contribute to personal and professional growth?",
    "options": [
      "It stunts individual growth and development",
      "It limits career opportunities and advancements",
      "It fosters critical thinking, creativity, and resilience",
      "Personal and professional growth is irrelevant to problem-solving"
    ],
    "answer": "It fosters critical thinking, creativity, and resilience"
  },
  {
    "id": 41,
    "topic": "General",
    "question": "Lecture 2: Algorithms & Data Structures **2.1 Objective: Introductory Concepts** 1. What is the primary objective of the \"Introductory Concepts\" in algorithms?",
    "options": [
      "Introduce complex algorithms",
      "Explore advanced data structures",
      "Familiarize learners with basic algorithmic concepts",
      "Teach programming languages"
    ],
    "answer": "Familiarize learners with basic algorithmic concepts"
  },
  {
    "id": 42,
    "topic": "General",
    "question": "2. What do \"Introductory Concepts\" in algorithms typically cover?",
    "options": [
      "Advanced mathematical principles",
      "Basics of data visualization",
      "Fundamental algorithmic ideas and terminology",
      "Principles of parallel processing"
    ],
    "answer": "Fundamental algorithmic ideas and terminology"
  },
  {
    "id": 43,
    "topic": "General",
    "question": "3. Why is it important to learn introductory concepts in algorithms?",
    "options": [
      "It helps in mastering complex programming languages",
      "It guarantees immediate success in problem-solving",
      "It forms the foundation for understanding advanced algorithms",
      "It is not essential in the field of computer science"
    ],
    "answer": "It forms the foundation for understanding advanced algorithms"
  },
  {
    "id": 44,
    "topic": "General",
    "question": "4. What is the scope of \"Introductory Concepts\" in algorithms?",
    "options": [
      "Covering only theoretical concepts",
      "Focusing exclusively on real-world applications",
      "Providing a broad overview of algorithmic principles",
      "Ignoring the concept of Big O notation"
    ],
    "answer": "Providing a broad overview of algorithmic principles"
  },
  {
    "id": 45,
    "topic": "General",
    "question": "5. Which of the following is NOT a typical topic covered in \"Introductory Concepts\"?",
    "options": [
      "Sorting algorithms",
      "Searching algorithms",
      "Basic data structures",
      "Complex optimization techniques"
    ],
    "answer": "Complex optimization techniques"
  },
  {
    "id": 46,
    "topic": "General",
    "question": "6. Which of the following is an example of a common introductory algorithmic concept?",
    "options": [
      "Hashing algorithms",
      "Graph traversal techniques",
      "Selection sort",
      "Advanced machine learning algorithms"
    ],
    "answer": "Selection sort"
  },
  {
    "id": 47,
    "topic": "General",
    "question": "7. What is the primary goal of learning introductory concepts in algorithms?",
    "options": [
      "Mastering a specific programming language",
      "Understanding complex data structures",
      "Preparing for a career in data analysis",
      "Building a strong foundation for further algorithmic studies"
    ],
    "answer": "Building a strong foundation for further algorithmic studies"
  },
  {
    "id": 48,
    "topic": "General",
    "question": "8. Why is it important to understand algorithmic concepts before delving into specific algorithms?",
    "options": [
      "To increase memorization capacity",
      "To appreciate the beauty of mathematics",
      "To make informed decisions in algorithm selection",
      "To avoid complex mathematical calculations"
    ],
    "answer": "To make informed decisions in algorithm selection"
  },
  {
    "id": 49,
    "topic": "General",
    "question": "9. What are some common algorithmic terminologies covered in introductory concepts?",
    "options": [
      "Database management terms",
      "Hardware-specific jargon",
      "Time complexity and space complexity",
      "Linguistic syntax in programming languages"
    ],
    "answer": "Time complexity and space complexity"
  },
  {
    "id": 50,
    "topic": "General",
    "question": "10. How can familiarity with introductory concepts benefit learners in their programming journey?",
    "options": [
      "By memorizing complex algorithms",
      "By avoiding data structures in problem-solving",
      "By providing a better understanding of algorithm design and analysis",
      "By eliminating the need for learning programming languages"
    ],
    "answer": "By providing a better understanding of algorithm design and analysis"
  },
  {
    "id": 51,
    "topic": "General",
    "question": "**2.2 Algorithm Constructs** 1. What are algorithm constructs in computer science?",
    "options": [
      "Physical components of a computer",
      "Fundamental building blocks used to design algorithms",
      "Popular programming languages",
      "Concepts related to database management"
    ],
    "answer": "Fundamental building blocks used to design algorithms"
  },
  {
    "id": 52,
    "topic": "General",
    "question": "2. What is the primary purpose of learning algorithm constructs?",
    "options": [
      "To create complex databases",
      "To implement machine learning models",
      "To design efficient algorithms to solve problems",
      "To build user interfaces for software applications"
    ],
    "answer": "To design efficient algorithms to solve problems"
  },
  {
    "id": 53,
    "topic": "General",
    "question": "3. Which of the following is an example of an algorithm construct?",
    "options": [
      "Database tables",
      "Graphical user interface",
      "Looping and conditional statements",
      "Computer network protocols"
    ],
    "answer": "Looping and conditional statements"
  },
  {
    "id": 54,
    "topic": "General",
    "question": "4. How do algorithm constructs contribute to problem-solving?",
    "options": [
      "They make problems more challenging to solve",
      "They offer ready-made solutions to complex issues",
      "They provide a structured approach to designing algorithms",
      "They eliminate the need for problem-solving"
    ],
    "answer": "They provide a structured approach to designing algorithms"
  },
  {
    "id": 55,
    "topic": "General",
    "question": "5. What is the significance of understanding algorithm constructs in computer science?",
    "options": [
      "It is not relevant to computer science",
      "It helps in becoming proficient in specific programming languages",
      "It aids in optimizing algorithms and improving efficiency",
      "It ensures immediate success in all programming tasks"
    ],
    "answer": "It aids in optimizing algorithms and improving efficiency"
  },
  {
    "id": 56,
    "topic": "General",
    "question": "6. Which of the following algorithm constructs is used to repeat a sequence of instructions?",
    "options": [
      "Conditionals",
      "Iterations (loops)",
      "Functions",
      "Variables"
    ],
    "answer": "Iterations (loops)"
  },
  {
    "id": 57,
    "topic": "General",
    "question": "7. What do algorithm constructs do when designing algorithms?",
    "options": [
      "They limit creativity and innovation",
      "They provide a structure for efficient problem-solving",
      "They replace the need for designing algorithms",
      "They make problems more difficult to understand"
    ],
    "answer": "They provide a structure for efficient problem-solving"
  },
  {
    "id": 58,
    "topic": "General",
    "question": "8. Why do programmers use algorithm constructs while writing code?",
    "options": [
      "To make code longer and more complicated",
      "To confuse users and create challenges",
      "To create algorithms that are easy to read and maintain",
      "To ignore problem-solving and programming principles"
    ],
    "answer": "To create algorithms that are easy to read and maintain"
  },
  {
    "id": 59,
    "topic": "General",
    "question": "9. How can algorithm constructs contribute to writing modular code?",
    "options": [
      "By making code monolithic and complex",
      "By promoting tightly coupled code segments",
      "By enabling code reuse and maintainability",
      "By eliminating the need for code organization"
    ],
    "answer": "By enabling code reuse and maintainability"
  },
  {
    "id": 60,
    "topic": "General",
    "question": "10. Which of the following is NOT a common algorithm construct used in programming?",
    "options": [
      "Conditional statements",
      "Loops",
      "Global variables",
      "Functions"
    ],
    "answer": "Global variables"
  },
  {
    "id": 61,
    "topic": "General",
    "question": "**2.3 Complexity analysis of algorithms (Big O notation)** 1. What is the primary goal of complexity analysis of algorithms using Big O notation?",
    "options": [
      "Identifying the smallest algorithms",
      "Analyzing the physical size of algorithms",
      "Evaluating the efficiency and performance of algorithms",
      "Comparing algorithms based on their difficulty level"
    ],
    "answer": "Evaluating the efficiency and performance of algorithms"
  },
  {
    "id": 62,
    "topic": "General",
    "question": "2. What does \"Big O notation\" represent in complexity analysis?",
    "options": [
      "The largest possible algorithm",
      "The time complexity of an algorithm",
      "The physical size of an algorithm's code",
      "The number of steps required to solve a problem"
    ],
    "answer": "The time complexity of an algorithm"
  },
  {
    "id": 63,
    "topic": "General",
    "question": "3. Why is it essential to analyze the complexity of algorithms?",
    "options": [
      "It guarantees finding the most straightforward algorithm",
      "It helps in choosing the most complex algorithm",
      "It ensures optimal algorithm design and resource management",
      "Complexity analysis is irrelevant in computer science"
    ],
    "answer": "It ensures optimal algorithm design and resource management"
  },
  {
    "id": 64,
    "topic": "General",
    "question": "ensures optimal algorithm design and resource management 4. What is the significance of using Big O notation in complexity analysis?",
    "options": [
      "It simplifies the code of algorithms",
      "It helps in reducing the number of steps in algorithms",
      "It provides a standardized way to express algorithm efficiency",
      "Big O notation is not relevant to complexity analysis"
    ],
    "answer": "It provides a standardized way to express algorithm efficiency"
  },
  {
    "id": 65,
    "topic": "General",
    "question": "5. Which of the following time complexities indicates the best-performing algorithm?",
    "options": [
      "O(1)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 66,
    "topic": "General",
    "question": "6. What is the time complexity of an algorithm with a linear time complexity?",
    "options": [
      "O(1)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 67,
    "topic": "General",
    "question": "7. How does the time complexity of an algorithm with O(n^2) compare to O(n)?",
    "options": [
      "O(n) is more efficient than O(n^2)",
      "O(n^2) is more efficient than O(n)",
      "O(n^2) and O(n) are equally efficient",
      "Both complexities have the same computational cost"
    ],
    "answer": "O(n) is more efficient than O(n^2)"
  },
  {
    "id": 68,
    "topic": "General",
    "question": "8. When analyzing the complexity of an algorithm, what does \"n\" typically represent?",
    "options": [
      "The number of steps in the algorithm",
      "The physical size of the algorithm",
      "The input size or number of elements in the algorithm",
      "The number of iterations in the algorithm"
    ],
    "answer": "The input size or number of elements in the algorithm"
  },
  {
    "id": 69,
    "topic": "General",
    "question": "9. Which of the following best describes an algorithm with constant time complexity (O(1))?",
    "options": [
      "The algorithm takes the same amount of time regardless of the input size",
      "The algorithm's performance improves linearly with the input size",
      "The algorithm's performance worsens exponentially with the input size",
      "The algorithm's performance varies unpredictably with the input size"
    ],
    "answer": "The algorithm takes the same amount of time regardless of the input size"
  },
  {
    "id": 70,
    "topic": "General",
    "question": "10. Why is it important to consider both time complexity and space complexity when analyzing algorithms?",
    "options": [
      "To increase the complexity of the algorithm",
      "To measure the efficiency of the algorithm's code",
      "To make the algorithm more difficult to understand",
      "To avoid analyzing the performance of the algorithm"
    ],
    "answer": "To measure the efficiency of the algorithm's code"
  },
  {
    "id": 71,
    "topic": "General",
    "question": "**2.4 Object-Oriented Design: Abstract Data Types (ADTs)** 1. What is the primary objective of learning about Abstract Data Types (ADTs) in algorithm design?",
    "options": [
      "Creating complex algorithms with unique data structures",
      "Ignoring the concept of data structures",
      "Implementing physical components of a computer",
      "Encapsulating data and operations in a reusable manner"
    ],
    "answer": "Encapsulating data and operations in a reusable manner"
  },
  {
    "id": 72,
    "topic": "General",
    "question": "2. How do Abstract Data Types (ADTs) contribute to algorithm design?",
    "options": [
      "They make algorithms more difficult to implement",
      "They offer ready-made solutions to complex issues",
      "They provide a high-level description of data and operations",
      "ADTs have no relevance to algorithm design"
    ],
    "answer": "They provide a high-level description of data and operations"
  },
  {
    "id": 73,
    "topic": "General",
    "question": "3. What distinguishes an Abstract Data Type (ADT) from a concrete data type?",
    "options": [
      "ADTs have no specific operations associated with them",
      "ADTs are limited to primitive data types",
      "ADTs are solely used in theoretical computer science",
      "Concrete data types have no relationship with algorithms"
    ],
    "answer": "ADTs have no specific operations associated with them"
  },
  {
    "id": 74,
    "topic": "General",
    "question": "4. How do Abstract Data Types (ADTs) promote modularity in algorithm design?",
    "options": [
      "They lead to monolithic and inflexible algorithms",
      "They encourage interdependence among data structures",
      "They allow algorithms to be designed independently of their implementation details",
      "ADTs do not contribute to modularity in algorithm design"
    ],
    "answer": "They allow algorithms to be designed independently of their implementation details"
  },
  {
    "id": 75,
    "topic": "General",
    "question": "5. Why is encapsulation essential in the design of Abstract Data Types (ADTs)?",
    "options": [
      "Encapsulation hinders data abstraction",
      "Encapsulation limits the reuse of code",
      "Encapsulation protects the internal details of data structures",
      "Encapsulation is irrelevant in data structure design"
    ],
    "answer": "Encapsulation protects the internal details of data structures"
  },
  {
    "id": 76,
    "topic": "General",
    "question": "6. Which of the following is NOT a common Abstract Data Type (ADT)?",
    "options": [
      "Stack",
      "Queue",
      "Binary search tree",
      "Loop"
    ],
    "answer": "Loop"
  },
  {
    "id": 77,
    "topic": "General",
    "question": "7. How does an Abstract Data Type (ADT) differ from a concrete data type in programming?",
    "options": [
      "ADTs are only used in theoretical computer science",
      "Concrete data types are more versatile than ADTs",
      "ADTs provide a high-level description without specifying the implementation",
      "Concrete data types are limited to primitive data structures"
    ],
    "answer": "ADTs provide a high-level description without specifying the implementation"
  },
  {
    "id": 78,
    "topic": "General",
    "question": "8. What does \"data abstraction\" mean in the context of Abstract Data Types (ADTs)?",
    "options": [
      "Hiding the internal details of data structures",
      "Displaying all the details of data structures",
      "Ignoring the implementation of data structures",
      "Avoiding the use of data structures in algorithms"
    ],
    "answer": "Hiding the internal details of data structures"
  },
  {
    "id": 79,
    "topic": "General",
    "question": "9. Why do programmers use Abstract Data Types (ADTs) in algorithm design?",
    "options": [
      "To make algorithms less efficient",
      "To make algorithms more complicated",
      "To encapsulate data and operations for easy reuse and maintenance",
      "To reduce the modularity of code"
    ],
    "answer": "To encapsulate data and operations for easy reuse and maintenance"
  },
  {
    "id": 80,
    "topic": "General",
    "question": "10. How do Abstract Data Types (ADTs) contribute to the object-oriented programming paradigm?",
    "options": [
      "By eliminating the use of objects in programming",
      "By promoting procedural programming practices",
      "By encapsulating data and behavior into objects",
      "ADTs have no relevance to object-oriented programming"
    ],
    "answer": "By encapsulating data and behavior into objects"
  },
  {
    "id": 81,
    "topic": "General",
    "question": "**2.5 Basic Data Structures** **2.5.1 Arrays** 1. What is an array in computer science?",
    "options": [
      "A collection of unrelated elements",
      "A linear data structure with fixed-size memory allocation",
      "A method for solving complex mathematical problems",
      "A representation of a computer network"
    ],
    "answer": "A linear data structure with fixed-size memory allocation"
  },
  {
    "id": 82,
    "topic": "General",
    "question": "2. How are elements arranged in an array?",
    "options": [
      "Randomly",
      "In a linear sequence",
      "In a hierarchical manner",
      "According to priority levels"
    ],
    "answer": "In a linear sequence"
  },
  {
    "id": 83,
    "topic": "General",
    "question": "3. What is the index of the first element in an array?",
    "options": [
      "-1",
      "0",
      "1",
      "It depends on the programming language"
    ],
    "answer": "0"
  },
  {
    "id": 84,
    "topic": "General",
    "question": "4. How can you access the element at index \"i\" in an array?",
    "options": [
      "array[i]",
      "array(index i)",
      "array(i)",
      "element[array(i)]"
    ],
    "answer": "array[i]"
  },
  {
    "id": 85,
    "topic": "General",
    "question": "5. What is the time complexity for accessing an element in an array with \"n\" elements?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 86,
    "topic": "General",
    "question": "6. What is the size of a fixed-size array with 10 elements?",
    "options": [
      "10",
      "9",
      "0",
      "It depends on the data type"
    ],
    "answer": "10"
  },
  {
    "id": 87,
    "topic": "General",
    "question": "7. What happens when you try to access an element outside the valid index range in an array?",
    "options": [
      "The program crashes",
      "The value at the invalid index is set to 0",
      "The element at the valid index is returned",
      "It depends on the programming language"
    ],
    "answer": "The program crashes"
  },
  {
    "id": 88,
    "topic": "General",
    "question": "8. What is the time complexity for inserting an element at the end of an array with \"n\" elements?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 89,
    "topic": "General",
    "question": "9. How can you initialize an array with all elements set to zero in many programming languages?",
    "options": [
      "array(0)",
      "array = []",
      "array = [0]",
      "It depends on the programming language"
    ],
    "answer": "It depends on the programming language"
  },
  {
    "id": 90,
    "topic": "General",
    "question": "10. What are some advantages of using arrays?",
    "options": [
      "They provide dynamic memory allocation",
      "They allow efficient element access and modification",
      "They are suitable for storing complex data structures",
      "They automatically resize based on the number of elements"
    ],
    "answer": "They allow efficient element access and modification"
  },
  {
    "id": 91,
    "topic": "General",
    "question": "**2.5.2 Stacks** 1. What is a stack in computer science?",
    "options": [
      "A linear data structure with variable size",
      "A collection of unrelated elements",
      "A hierarchical data structure",
      "A method for sorting data"
    ],
    "answer": "A linear data structure with variable size"
  },
  {
    "id": 92,
    "topic": "General",
    "question": "2. How are elements added to a stack?",
    "options": [
      "Elements are randomly added",
      "Elements are inserted at the front",
      "Elements are inserted at the end",
      "Elements are inserted at the top"
    ],
    "answer": "Elements are inserted at the top"
  },
  {
    "id": 93,
    "topic": "General",
    "question": "3. What is the term used to describe the process of adding an element to a stack?",
    "options": [
      "Insertion",
      "Push",
      "Append",
      "Enqueue"
    ],
    "answer": "Push"
  },
  {
    "id": 94,
    "topic": "General",
    "question": "4. What happens when you try to remove an element from an empty stack?",
    "options": [
      "The program crashes",
      "The top element is removed",
      "The stack becomes double-ended",
      "A new element is added"
    ],
    "answer": "The program crashes"
  },
  {
    "id": 95,
    "topic": "General",
    "question": "5. What is the time complexity for adding an element to a stack?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 96,
    "topic": "General",
    "question": "6. What is the term used to describe the process of removing an element from a stack?",
    "options": [
      "Removal",
      "Pop",
      "Remove",
      "Dequeue"
    ],
    "answer": "Pop"
  },
  {
    "id": 97,
    "topic": "General",
    "question": "7. What happens when you try to add an element to a full stack?",
    "options": [
      "The program crashes",
      "The oldest element is removed to make space",
      "The stack automatically resizes to accommodate the new element",
      "The element is added to a different data structure"
    ],
    "answer": "The program crashes"
  },
  {
    "id": 98,
    "topic": "General",
    "question": "8. What is the time complexity for removing an element from a stack?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 99,
    "topic": "General",
    "question": "9. What is the last-in, first-out (LIFO) property of a stack?",
    "options": [
      "The last element added is the first to be removed",
      "The first element added is the first to be removed",
      "Elements are removed in random order",
      "Elements are removed based on their values"
    ],
    "answer": "The last element added is the first to be removed"
  },
  {
    "id": 100,
    "topic": "General",
    "question": "10. What are some common applications of stacks in computer science?",
    "options": [
      "Sorting algorithms",
      "Implementing recursive functions",
      "Graph traversal algorithms",
      "Database management"
    ],
    "answer": "Implementing recursive functions"
  },
  {
    "id": 101,
    "topic": "General",
    "question": "**2.5.3 Queues** 1. What is a queue in computer science?",
    "options": [
      "A linear data structure with variable size",
      "A collection of unrelated elements",
      "A hierarchical data structure",
      "A method for sorting data"
    ],
    "answer": "A linear data structure with variable size"
  },
  {
    "id": 102,
    "topic": "General",
    "question": "2. How are elements added to a queue?",
    "options": [
      "Elements are randomly added",
      "Elements are inserted at the front",
      "Elements are inserted at the end",
      "Elements are inserted at the top"
    ],
    "answer": "Elements are inserted at the end"
  },
  {
    "id": 103,
    "topic": "General",
    "question": "3. What is the term used to describe the process of adding an element to a queue?",
    "options": [
      "Insertion",
      "Push",
      "Append",
      "Enqueue"
    ],
    "answer": "Enqueue"
  },
  {
    "id": 104,
    "topic": "General",
    "question": "4. What happens when you try to remove an element from an empty queue?",
    "options": [
      "The program crashes",
      "The front element is removed",
      "The queue becomes double-ended",
      "A new element is added"
    ],
    "answer": "The program crashes"
  },
  {
    "id": 105,
    "topic": "General",
    "question": "5. What is the time complexity for adding an element to a queue?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 106,
    "topic": "General",
    "question": "6. What is the term used to describe the process of removing an element from a queue?",
    "options": [
      "Removal",
      "Pop",
      "Remove",
      "Dequeue"
    ],
    "answer": "Dequeue"
  },
  {
    "id": 107,
    "topic": "General",
    "question": "7. What happens when you try to add an element to a full queue?",
    "options": [
      "The program crashes",
      "The oldest element is removed to make space",
      "The queue automatically resizes to accommodate the new element",
      "The element is added to a different data structure"
    ],
    "answer": "The program crashes"
  },
  {
    "id": 108,
    "topic": "General",
    "question": "8. What is the time complexity for removing an element from a queue?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 109,
    "topic": "General",
    "question": "9. What is the first-in, first-out (FIFO) property of a queue?",
    "options": [
      "The last element added is the first to be removed",
      "The first element added is the first to be removed",
      "Elements are removed in random order",
      "Elements are removed based on their values"
    ],
    "answer": "The first element added is the first to be removed"
  },
  {
    "id": 110,
    "topic": "General",
    "question": "10. What are some common applications of queues in computer science?",
    "options": [
      "Sorting algorithms",
      "Implementing recursive functions",
      "Graph traversal algorithms",
      "Scheduling tasks in operating systems"
    ],
    "answer": "Scheduling tasks in operating systems"
  },
  {
    "id": 111,
    "topic": "General",
    "question": "**2.5.4 Circular Queues** 1. What is a circular queue?",
    "options": [
      "A queue with no elements",
      "A queue that can only contain a fixed number of elements",
      "A queue with elements arranged in a circular manner",
      "A queue that allows elements to be inserted at the front"
    ],
    "answer": "A queue with elements arranged in a circular manner"
  },
  {
    "id": 112,
    "topic": "General",
    "question": "2. How does a circular queue handle the issue of space when adding elements?",
    "options": [
      "It automatically resizes to accommodate more elements",
      "It overwrites the oldest element to make space for new elements",
      "It throws an error when the queue is full",
      "It cannot add elements once the queue is full"
    ],
    "answer": "It overwrites the oldest element to make space for new elements"
  },
  {
    "id": 113,
    "topic": "General",
    "question": "3. What is the time complexity for adding an element to a circular queue?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 114,
    "topic": "General",
    "question": "4. What is the time complexity for removing an element from a circular queue?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 115,
    "topic": "General",
    "question": "5. What happens when you try to remove an element from an empty circular queue?",
    "options": [
      "The program crashes",
      "The front element is removed",
      "The circular queue becomes double-ended",
      "A new element is added"
    ],
    "answer": "The program crashes"
  },
  {
    "id": 116,
    "topic": "General",
    "question": "6. What is the term used to describe the process of adding an element to a circular queue?",
    "options": [
      "Insertion",
      "Push",
      "Append",
      "Enqueue"
    ],
    "answer": "Enqueue"
  },
  {
    "id": 117,
    "topic": "General",
    "question": "7. What is the term used to describe the process of removing an element from a circular queue?",
    "options": [
      "Removal",
      "Pop",
      "Remove",
      "Dequeue"
    ],
    "answer": "Dequeue"
  },
  {
    "id": 118,
    "topic": "General",
    "question": "8. What is the first-in, first-out (FIFO) property of a circular queue?",
    "options": [
      "The last element added is the first to be removed",
      "The first element added is the first to be removed",
      "Elements are removed in random order",
      "Elements are removed based on their values"
    ],
    "answer": "The first element added is the first to be removed"
  },
  {
    "id": 119,
    "topic": "General",
    "question": "9. What is the main advantage of using a circular queue over a regular queue?",
    "options": [
      "It provides faster insertion and removal of elements",
      "It requires less memory for implementation",
      "It guarantees a fixed size for the queue",
      "It prevents queue overflow and underflow"
    ],
    "answer": "It prevents queue overflow and underflow"
  },
  {
    "id": 120,
    "topic": "General",
    "question": "10. In a circular queue, how do you calculate the next position for insertion after reaching the last position?",
    "options": [
      "Move to the first position",
      "Stay at the last position",
      "Move to the position after the last position",
      "It depends on the implementation"
    ],
    "answer": "Move to the first position"
  },
  {
    "id": 121,
    "topic": "General",
    "question": "Lecture 3: Linked List Data Structures **3.1 Linked Lists** 1. What is a linked list in computer science?",
    "options": [
      "A collection of unrelated elements",
      "A linear data structure with fixed-size memory allocation",
      "A hierarchical data structure",
      "A linear data structure with dynamic memory allocation"
    ],
    "answer": "A linear data structure with dynamic memory allocation"
  },
  {
    "id": 122,
    "topic": "General",
    "question": "2. How are elements organized in a linked list?",
    "options": [
      "In a linear sequence",
      "In a random order",
      "In a hierarchical manner",
      "According to priority levels"
    ],
    "answer": "In a linear sequence"
  },
  {
    "id": 123,
    "topic": "General",
    "question": "3. What is the primary advantage of using linked lists over arrays?",
    "options": [
      "Linked lists are more memory-efficient",
      "Linked lists provide faster access to elements",
      "Linked lists offer constant-time insertion and deletion",
      "Linked lists have a fixed size"
    ],
    "answer": "Linked lists offer constant-time insertion and deletion"
  },
  {
    "id": 124,
    "topic": "General",
    "question": "4. What is the time complexity for accessing an element in a singly linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 125,
    "topic": "General",
    "question": "5. How are elements connected in a singly linked list?",
    "options": [
      "Each element points to the previous element",
      "Each element points to the next element",
      "Each element points to a random element",
      "Each element points to all other elements"
    ],
    "answer": "Each element points to the next element"
  },
  {
    "id": 126,
    "topic": "General",
    "question": "6. What is the term used to describe the first element in a linked list?",
    "options": [
      "First element",
      "Front element",
      "Head",
      "Top element"
    ],
    "answer": "Head"
  },
  {
    "id": 127,
    "topic": "General",
    "question": "7. What is the term used to describe the last element in a linked list?",
    "options": [
      "Last element",
      "End element",
      "Tail",
      "Rear element"
    ],
    "answer": "Tail"
  },
  {
    "id": 128,
    "topic": "General",
    "question": "8. What happens when you try to access an element outside the valid index range in a linked list?",
    "options": [
      "The program crashes",
      "The value at the invalid index is set to 0",
      "The element at the valid index is returned",
      "It depends on the programming language"
    ],
    "answer": "The program crashes"
  },
  {
    "id": 129,
    "topic": "General",
    "question": "9. What is the time complexity for inserting an element at the beginning of a singly linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 130,
    "topic": "General",
    "question": "10. What is the time complexity for removing an element from the beginning of a singly linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 131,
    "topic": "General",
    "question": "**3.1.1 Singly Linked Lists** 1. What is the primary characteristic of a singly linked list?",
    "options": [
      "Each element has two pointers - one for the previous element and one for the next element",
      "Each element has one pointer pointing to the previous element",
      "Each element has one pointer pointing to the next element",
      "Elements are organized in a circular manner"
    ],
    "answer": "Each element has one pointer pointing to the next element"
  },
  {
    "id": 132,
    "topic": "General",
    "question": "2. How many pointers does the last element in a singly linked list have?",
    "options": [
      "One pointing to the next element",
      "Two - one for the previous element and one for the next element",
      "None - it does not point to any element",
      "It depends on the implementation"
    ],
    "answer": "None - it does not point to any element"
  },
  {
    "id": 133,
    "topic": "General",
    "question": "3. How do you traverse a singly linked list from the beginning to the end?",
    "options": [
      "Move in a random order",
      "Follow the pointers from one element to the previous element",
      "Follow the pointers from one element to the next element",
      "Jump directly to the middle element"
    ],
    "answer": "Follow the pointers from one element to the next element"
  },
  {
    "id": 134,
    "topic": "General",
    "question": "4. What is the primary advantage of using a singly linked list over a doubly linked list?",
    "options": [
      "Singly linked lists allow constant-time deletion of elements",
      "Singly linked lists require less memory per element",
      "Singly linked lists provide faster traversal in both directions",
      "Singly linked lists are more memory-efficient"
    ],
    "answer": "Singly linked lists require less memory per element"
  },
  {
    "id": 135,
    "topic": "General",
    "question": "5. What is the time complexity for accessing an element in a singly linked list at a specific index?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 136,
    "topic": "General",
    "question": "6. How do you add an element to the end of a singly linked list?",
    "options": [
      "Change the pointer of the last element to point to the new element",
      "Change the pointer of the first element to point to the new element",
      "Create a new list with the new element and append it to the existing list",
      "Singly linked lists do not support adding elements to the end"
    ],
    "answer": "Change the pointer of the last element to point to the new element"
  },
  {
    "id": 137,
    "topic": "General",
    "question": "7. What is the time complexity for inserting an element at the end of a singly linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 138,
    "topic": "General",
    "question": "8. How do you remove an element from the middle of a singly linked list?",
    "options": [
      "Change the pointer of the previous element to point to the next element",
      "Change the pointer of the next element to point to the previous element",
      "Remove the element and update the pointers of adjacent elements",
      "Singly linked lists do not support removal of elements from the middle"
    ],
    "answer": "Remove the element and update the pointers of adjacent elements"
  },
  {
    "id": 139,
    "topic": "General",
    "question": "9. What is the time complexity for removing an element from the middle of a singly linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 140,
    "topic": "General",
    "question": "10. What is the main disadvantage of using a singly linked list?",
    "options": [
      "It requires more memory per element compared to arrays",
      "It does not allow constant-time access to elements at arbitrary positions",
      "It is more difficult to implement than other data structures",
      "Singly linked lists do not have any disadvantages"
    ],
    "answer": "It does not allow constant-time access to elements at arbitrary positions"
  },
  {
    "id": 141,
    "topic": "General",
    "question": "**3.1.2 Doubly Linked Lists** 1. What is the primary characteristic of a doubly linked list?",
    "options": [
      "Each element has two pointers - one for the previous element and one for the next element",
      "Each element has one pointer pointing to the previous element",
      "Each element has one pointer pointing to the next element",
      "Elements are organized in a circular manner"
    ],
    "answer": "Each element has two pointers - one for the previous element and one for the next element"
  },
  {
    "id": 142,
    "topic": "General",
    "question": "2. How many pointers does the first element in a doubly linked list have?",
    "options": [
      "One pointing to the next element",
      "Two - one for the previous element and one for the next element",
      "None - it does not point to any element",
      "It depends on the implementation"
    ],
    "answer": "None - it does not point to any element"
  },
  {
    "id": 143,
    "topic": "General",
    "question": "3. How do you traverse a doubly linked list from the beginning to the end?",
    "options": [
      "Move in a random order",
      "Follow the pointers from one element to the previous element",
      "Follow the pointers from one element to the next element",
      "Jump directly to the middle element"
    ],
    "answer": "Follow the pointers from one element to the next element"
  },
  {
    "id": 144,
    "topic": "General",
    "question": "4. What is the primary advantage of using a doubly linked list over a singly linked list?",
    "options": [
      "Doubly linked lists allow constant-time deletion of elements",
      "Doubly linked lists require less memory per element",
      "Doubly linked lists provide faster traversal in both directions",
      "Doubly linked lists are more memory-efficient"
    ],
    "answer": "Doubly linked lists provide faster traversal in both directions"
  },
  {
    "id": 145,
    "topic": "General",
    "question": "5. What is the time complexity for accessing an element in a doubly linked list at a specific index?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 146,
    "topic": "General",
    "question": "6. How do you add an element to the end of a doubly linked list?",
    "options": [
      "Change the pointer of the last element to point to the new element",
      "Change the pointer of the first element to point to the new element",
      "Create a new list with the new element and append it to the existing list",
      "Doubly linked lists do not support adding elements to the end"
    ],
    "answer": "Change the pointer of the last element to point to the new element"
  },
  {
    "id": 147,
    "topic": "General",
    "question": "7. What is the time complexity for inserting an element at the end of a doubly linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 148,
    "topic": "General",
    "question": "8. How do you remove an element from the middle of a doubly linked list?",
    "options": [
      "Change the pointer of the previous element to point to the next element",
      "Change the pointer of the next element to point to the previous element",
      "Remove the element and update the pointers of adjacent elements",
      "Doubly linked lists do not support removal of elements from the middle"
    ],
    "answer": "Remove the element and update the pointers of adjacent elements"
  },
  {
    "id": 149,
    "topic": "General",
    "question": "9. What is the time complexity for removing an element from the middle of a doubly linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 150,
    "topic": "General",
    "question": "10. What is the main advantage of using a doubly linked list over a singly linked list?",
    "options": [
      "Doubly linked lists require less memory per element",
      "Doubly linked lists allow constant-time access to elements at arbitrary positions",
      "Doubly linked lists are easier to implement than singly linked lists",
      "Doubly linked lists have no advantages over singly linked lists"
    ],
    "answer": "Doubly linked lists allow constant-time access to elements at arbitrary positions"
  },
  {
    "id": 151,
    "topic": "General",
    "question": "**3.1.3 Circular Linked Lists** 1. What is the primary characteristic of a circular linked list?",
    "options": [
      "Elements are organized in a circular manner",
      "Each element has two pointers - one for the previous element and one for the next element",
      "Each element has one pointer pointing to the previous element",
      "Each element has one pointer pointing to the next element"
    ],
    "answer": "Elements are organized in a circular manner"
  },
  {
    "id": 152,
    "topic": "General",
    "question": "2. How are elements connected in a circular linked list?",
    "options": [
      "Each element points to the previous element",
      "Each element points to the next element",
      "Each element points to all other elements",
      "Each element does not point to any element"
    ],
    "answer": "Each element points to the next element"
  },
  {
    "id": 153,
    "topic": "General",
    "question": "3. What is the term used to describe the first element in a circular linked list?",
    "options": [
      "First element",
      "Front element",
      "Head",
      "Top element"
    ],
    "answer": "Head"
  },
  {
    "id": 154,
    "topic": "General",
    "question": "4. What is the term used to describe the last element in a circular linked list?",
    "options": [
      "Last element",
      "End element",
      "Tail",
      "Rear element"
    ],
    "answer": "Tail"
  },
  {
    "id": 155,
    "topic": "General",
    "question": "5. What is the time complexity for accessing an element in a circular linked list at a specific index?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 156,
    "topic": "General",
    "question": "6. How do you add an element to the end of a circular linked list?",
    "options": [
      "Change the pointer of the last element to point to the new element",
      "Change the pointer of the first element to point to the new element",
      "Create a new list with the new element and append it to the existing list",
      "Circular linked lists do not support adding elements to the end"
    ],
    "answer": "Change the pointer of the last element to point to the new element"
  },
  {
    "id": 157,
    "topic": "General",
    "question": "7. What is the time complexity for inserting an element at the end of a circular linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 158,
    "topic": "General",
    "question": "8. How do you remove an element from the middle of a circular linked list?",
    "options": [
      "Change the pointer of the previous element to point to the next element",
      "Change the pointer of the next element to point to the previous element",
      "Remove the element and update the pointers of adjacent elements",
      "Circular linked lists do not support removal of elements from the middle"
    ],
    "answer": "Remove the element and update the pointers of adjacent elements"
  },
  {
    "id": 159,
    "topic": "General",
    "question": "9. What is the time complexity for removing an element from the middle of a circular linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 160,
    "topic": "General",
    "question": "10. What is the main advantage of using a circular linked list over a singly linked list?",
    "options": [
      "Circular linked lists require less memory per element",
      "Circular linked lists allow constant-time access to elements at arbitrary positions",
      "Circular linked lists provide faster traversal in both directions",
      "Circular linked lists have no advantages over singly linked lists"
    ],
    "answer": "Circular linked lists provide faster traversal in both directions"
  },
  {
    "id": 161,
    "topic": "General",
    "question": "**3.1.4 Node-based Storage with Arrays** 1. What is node-based storage in the context of linked lists?",
    "options": [
      "A method of storing linked lists using arrays",
      "A method of storing linked lists using nodes",
      "A method of storing linked lists using pointers",
      "A method of storing linked lists using circular arrays"
    ],
    "answer": "A method of storing linked lists using nodes"
  },
  {
    "id": 162,
    "topic": "General",
    "question": "2. What is a node in the context of linked lists?",
    "options": [
      "An element in an array",
      "A collection of unrelated elements",
      "A data structure containing data and a pointer to the next element",
      "A hierarchical data structure"
    ],
    "answer": "A data structure containing data and a pointer to the next element"
  },
  {
    "id": 163,
    "topic": "General",
    "question": "3. How are elements connected in a node-based storage linked list?",
    "options": [
      "Each node points to the previous node",
      "Each node points to the next node",
      "Each node points to all other nodes",
      "Each node does not point to any node"
    ],
    "answer": "Each node points to the next node"
  },
  {
    "id": 164,
    "topic": "General",
    "question": "4. What is the time complexity for accessing an element in a node-based storage linked list at a specific index?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 165,
    "topic": "General",
    "question": "5. What is the primary advantage of using node-based storage with arrays over standard arrays?",
    "options": [
      "It provides faster access to elements",
      "It allows constant-time insertion and deletion",
      "It requires less memory per element",
      "It provides faster traversal in both directions"
    ],
    "answer": "It allows constant-time insertion and deletion"
  },
  {
    "id": 166,
    "topic": "General",
    "question": "6. What is the time complexity for inserting an element at the end of a node-based storage linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 167,
    "topic": "General",
    "question": "7. How do you add an element to the beginning of a node-based storage linked list?",
    "options": [
      "Change the pointer of the first node to point to the new node",
      "Change the pointer of the last node to point to the new node",
      "Create a new list with the new element and append it to the existing list",
      "Node-based storage linked lists do not support adding elements to the beginning"
    ],
    "answer": "Change the pointer of the first node to point to the new node"
  },
  {
    "id": 168,
    "topic": "General",
    "question": "8. What is the time complexity for inserting an element at the beginning of a node-based storage linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 169,
    "topic": "General",
    "question": "9. How do you remove an element from the middle of a node-based storage linked list?",
    "options": [
      "Change the pointer of the previous node to point to the next node",
      "Change the pointer of the next node to point to the previous node",
      "Remove the node and update the pointers of adjacent nodes",
      "Node-based storage linked lists do not support removal of elements from the middle"
    ],
    "answer": "Remove the node and update the pointers of adjacent nodes"
  },
  {
    "id": 170,
    "topic": "General",
    "question": "10. What is the time complexity for removing an element from the middle of a node-based storage linked list?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 171,
    "topic": "General",
    "question": "Lecture 4: Recursion **4.1 What is recursion?** 1. Recursion is a programming technique where a function calls itself directly or indirectly until it reaches a specific condition called the:",
    "options": [
      "Loop condition",
      "Recursive condition",
      "Base condition",
      "Termination condition"
    ],
    "answer": "Base condition"
  },
  {
    "id": 172,
    "topic": "General",
    "question": "2. In recursion, what happens when a function calls itself?",
    "options": [
      "The function is terminated",
      "A new function is created with a different name",
      "The function executes the same set of statements repeatedly",
      "A new instance of the function is created and added to the stack"
    ],
    "answer": "A new instance of the function is created and added to the stack"
  },
  {
    "id": 173,
    "topic": "General",
    "question": "3. Recursion provides an alternative approach to solving problems that can also be solved using:",
    "options": [
      "Loops",
      "Arrays",
      "Pointers",
      "Switch statements"
    ],
    "answer": "Loops"
  },
  {
    "id": 174,
    "topic": "General",
    "question": "4. Which of the following is NOT an essential component of a recursive function?",
    "options": [
      "Base condition",
      "Recursive call",
      "Looping mechanism",
      "Exit condition"
    ],
    "answer": "Looping mechanism"
  },
  {
    "id": 175,
    "topic": "General",
    "question": "5. What is the main advantage of using recursion in programming?",
    "options": [
      "It provides faster execution of code",
      "It reduces memory consumption",
      "It simplifies the code and problem-solving process",
      "It eliminates the need for the base condition"
    ],
    "answer": "It simplifies the code and problem-solving process"
  },
  {
    "id": 176,
    "topic": "General",
    "question": "6. What is tail recursion?",
    "options": [
      "A type of recursion that involves only one function call",
      "A type of recursion that involves multiple function calls",
      "A type of recursion that occurs when a function calls itself multiple times",
      "A type of recursion that occurs when a function calls another function"
    ],
    "answer": "A type of recursion that involves only one function call"
  },
  {
    "id": 177,
    "topic": "General",
    "question": "7. Recursion is used in various algorithms and data structures, such as:",
    "options": [
      "Sorting algorithms",
      "Arrays",
      "Pointers",
      "Switch statements"
    ],
    "answer": "Sorting algorithms"
  },
  {
    "id": 178,
    "topic": "General",
    "question": "8. What happens if a recursive function does not have a base condition?",
    "options": [
      "The program executes the recursive calls indefinitely",
      "The program enters an infinite loop",
      "The program terminates successfully",
      "The program throws a runtime error"
    ],
    "answer": "The program executes the recursive calls indefinitely"
  },
  {
    "id": 179,
    "topic": "General",
    "question": "9. What is the time complexity of a recursive algorithm with exponential growth?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(2^n)"
    ],
    "answer": "O(2^n)"
  },
  {
    "id": 180,
    "topic": "General",
    "question": "10. Recursion can be considered as an alternative to which of the following programming constructs?",
    "options": [
      "Decision-making statements (if-else)",
      "Looping statements (for, while)",
      "Function declarations",
      "Variable declarations"
    ],
    "answer": "Looping statements (for, while)"
  },
  {
    "id": 181,
    "topic": "General",
    "question": "**4.2 What is the base condition in recursion?** 1. The base condition in recursion is also known as the:",
    "options": [
      "Terminating condition",
      "Halt condition",
      "Stopping condition",
      "Exit condition"
    ],
    "answer": "Terminating condition"
  },
  {
    "id": 182,
    "topic": "General",
    "question": "2. The base condition is crucial in recursion to:",
    "options": [
      "Terminate the recursive function",
      "Ensure the function calls itself indefinitely",
      "Control the order of function execution",
      "Allow the recursive function to call other functions"
    ],
    "answer": "Terminate the recursive function"
  },
  {
    "id": 183,
    "topic": "General",
    "question": "3. In a recursive function, the base condition is typically expressed using:",
    "options": [
      "A loop",
      "An if-else statement",
      "A switch statement",
      "A function call"
    ],
    "answer": "An if-else statement"
  },
  {
    "id": 184,
    "topic": "General",
    "question": "4. What happens when the base condition is met in a recursive function?",
    "options": [
      "The function starts calling other functions",
      "The recursive function stops calling itself and returns a value",
      "The function enters an infinite loop",
      "The function terminates without returning any value"
    ],
    "answer": "The recursive function stops calling itself and returns a value"
  },
  {
    "id": 185,
    "topic": "General",
    "question": "5. The base condition prevents the recursive function from:",
    "options": [
      "Starting the recursion process",
      "Reaching the recursive call",
      "Returning any value",
      "Performing any operation"
    ],
    "answer": "Starting the recursion process"
  },
  {
    "id": 186,
    "topic": "General",
    "question": "6. How many times does a recursive function call itself when the base condition is met?",
    "options": [
      "Zero times",
      "One time",
      "Multiple times",
      "It depends on the implementation"
    ],
    "answer": "Zero times"
  },
  {
    "id": 187,
    "topic": "General",
    "question": "7. What is the purpose of the base condition in recursion?",
    "options": [
      "To determine the input parameters for the recursive call",
      "To set a limit on the number of recursive calls",
      "To control the order of function execution",
      "To determine the output of the recursive function"
    ],
    "answer": "To set a limit on the number of recursive calls"
  },
  {
    "id": 188,
    "topic": "General",
    "question": "8. The absence of a base condition in recursion can lead to:",
    "options": [
      "Faster execution of the program",
      "Infinite recursion and stack overflow",
      "Reduced memory consumption",
      "More accurate results"
    ],
    "answer": "Infinite recursion and stack overflow"
  },
  {
    "id": 189,
    "topic": "General",
    "question": "9. The base condition is typically defined based on the:",
    "options": [
      "Input parameters of the function",
      "Output of the recursive function",
      "Current state of the program",
      "Complexity of the problem being solved"
    ],
    "answer": "Input parameters of the function"
  },
  {
    "id": 190,
    "topic": "General",
    "question": "10. What happens if the base condition is not met during recursion?",
    "options": [
      "The program terminates successfully",
      "The recursive function halts execution",
      "The program enters an infinite loop",
      "The function returns the default value of its return type"
    ],
    "answer": "The program enters an infinite loop"
  },
  {
    "id": 191,
    "topic": "General",
    "question": "**4.3 Direct and Indirect Recursion** 1. Direct recursion refers to a situation where a function calls:",
    "options": [
      "Itself directly",
      "Another function directly",
      "Itself indirectly through another function",
      "Multiple functions simultaneously"
    ],
    "answer": "Itself directly"
  },
  {
    "id": 192,
    "topic": "General",
    "question": "2. Indirect recursion refers to a situation where a function calls:",
    "options": [
      "Itself directly",
      "Another function directly",
      "Itself indirectly through another function",
      "Multiple functions simultaneously"
    ],
    "answer": "Itself indirectly through another function"
  },
  {
    "id": 193,
    "topic": "General",
    "question": "3. In direct recursion, a function calls itself:",
    "options": [
      "Without involving any other functions",
      "With multiple function calls simultaneously",
      "Through a separate utility function",
      "With different parameters"
    ],
    "answer": "Without involving any other functions"
  },
  {
    "id": 194,
    "topic": "General",
    "question": "4. In indirect recursion, multiple functions:",
    "options": [
      "Call each other in a loop",
      "Call each other directly",
      "Call each other indirectly through a chain of function calls",
      "Do not interact with each other"
    ],
    "answer": "Call each other indirectly through a chain of function calls"
  },
  {
    "id": 195,
    "topic": "General",
    "question": "5. Which of the following statements is true for direct and indirect recursion?",
    "options": [
      "Both direct and indirect recursion involve only one function call",
      "Direct recursion involves only one function call, while indirect recursion involves multiple function calls",
      "Indirect recursion involves only one function call, while direct recursion involves multiple function calls",
      "Both direct and indirect recursion involve multiple function calls"
    ],
    "answer": "Both direct and indirect recursion involve multiple function calls"
  },
  {
    "id": 196,
    "topic": "General",
    "question": "6. Direct recursion is more straightforward to implement than indirect recursion because:",
    "options": [
      "It involves fewer function calls",
      "It does not require any base condition",
      "It does not require the use of other functions",
      "It allows for faster execution of code"
    ],
    "answer": "It does not require the use of other functions"
  },
  {
    "id": 197,
    "topic": "General",
    "question": "7. Indirect recursion can be useful when:",
    "options": [
      "The recursive logic is complex and needs to be split into multiple functions",
      "The base condition is not known at the beginning of the recursion",
      "The recursive function needs to be called with different parameters",
      "There is a limitation on the number of recursive calls"
    ],
    "answer": "The recursive logic is complex and needs to be split into multiple functions"
  },
  {
    "id": 198,
    "topic": "General",
    "question": "8. What happens if the base condition is not defined correctly in indirect recursion?",
    "options": [
      "The program terminates successfully",
      "The recursive function halts execution",
      "The program enters an infinite loop",
      "The function returns the default value of its return type"
    ],
    "answer": "The program enters an infinite loop"
  },
  {
    "id": 199,
    "topic": "General",
    "question": "9. In direct recursion, the control flow remains within the:",
    "options": [
      "Base condition",
      "Recursive call",
      "Main function",
      "Recursive function"
    ],
    "answer": "Recursive function"
  },
  {
    "id": 200,
    "topic": "General",
    "question": "10. In indirect recursion, the control flow moves between:",
    "options": [
      "Two different functions",
      "Base condition and recursive call",
      "Multiple recursive calls",
      "The main function and recursive function"
    ],
    "answer": "Two different functions"
  },
  {
    "id": 201,
    "topic": "General",
    "question": "**4.4 Memory is Allocated to Different Function Calls in Recursion** 1. In recursion, each function call creates its own:",
    "options": [
      "Local variables",
      "Global variables",
      "Shared variables",
      "Constants"
    ],
    "answer": "Local variables"
  },
  {
    "id": 202,
    "topic": "General",
    "question": "2. Each instance of a recursive function call has its own set of:",
    "options": [
      "Input parameters",
      "Output parameters",
      "Local variables",
      "Static variables"
    ],
    "answer": "Local variables"
  },
  {
    "id": 203,
    "topic": "General",
    "question": "3. The memory for local variables of a recursive function is allocated on the:",
    "options": [
      "Heap",
      "Stack",
      "Data segment",
      "Code segment"
    ],
    "answer": "Stack"
  },
  {
    "id": 204,
    "topic": "General",
    "question": "4. What happens when a recursive function calls itself multiple times?",
    "options": [
      "All function calls share the same local variables",
      "All function calls share the same memory address",
      "Each function call has its own copy of local variables",
      "Each function call updates the memory of previous calls"
    ],
    "answer": "Each function call has its own copy of local variables"
  },
  {
    "id": 205,
    "topic": "General",
    "question": "5. The memory allocated to each function call in recursion is deallocated:",
    "options": [
      "When the base condition is met",
      "After the recursive call",
      "Automatically by the compiler",
      "Manually by the programmer"
    ],
    "answer": "When the base condition is met"
  },
  {
    "id": 206,
    "topic": "General",
    "question": "6. Excessive recursion or recursion with a large number of function calls can lead to:",
    "options": [
      "Increased memory consumption",
      "Stack overflow and program crash",
      "Faster execution of the program",
      "Better performance"
    ],
    "answer": "Stack overflow and program crash"
  },
  {
    "id": 207,
    "topic": "General",
    "question": "7. What is a potential disadvantage of recursion regarding memory usage?",
    "options": [
      "Recursion does not use any memory",
      "Recursion consumes a fixed amount of memory",
      "Recursion consumes more memory compared to iteration",
      "Recursion consumes less memory compared to iteration"
    ],
    "answer": "Recursion consumes more memory compared to iteration"
  },
  {
    "id": 208,
    "topic": "General",
    "question": "8. The memory used for recursive function calls is managed by the:",
    "options": [
      "Operating system",
      "Compiler",
      "Programmer",
      "Recursive function itself"
    ],
    "answer": "Operating system"
  },
  {
    "id": 209,
    "topic": "General",
    "question": "9. What is the purpose of allocating memory separately for each function call in recursion?",
    "options": [
      "To ensure faster execution of the program",
      "To allow for easy sharing of data between function calls",
      "To prevent memory leaks",
      "To allow for parallel execution of function calls"
    ],
    "answer": "To prevent memory leaks"
  },
  {
    "id": 210,
    "topic": "General",
    "question": "10. When does the memory allocated to a recursive function call get released?",
    "options": [
      "When the recursive call is made",
      "After the base condition is met",
      "When the program terminates",
      "When the recursive call is completed"
    ],
    "answer": "After the base condition is met"
  },
  {
    "id": 211,
    "topic": "General",
    "question": "**4.5 Pros and Cons of Recursion** 1. What is a major advantage of using recursion in programming?",
    "options": [
      "Recursion allows for faster execution of code",
      "Recursion reduces memory consumption",
      "Recursion simplifies complex problems and algorithms",
      "Recursion eliminates the need for loops"
    ],
    "answer": "Recursion simplifies complex problems and algorithms"
  },
  {
    "id": 212,
    "topic": "General",
    "question": "2. Recursion can lead to a more concise and readable code compared to:",
    "options": [
      "Functions with loops",
      "Functions with multiple return statements",
      "Functions with many parameters",
      "Functions with a single return statement"
    ],
    "answer": "Functions with loops"
  },
  {
    "id": 213,
    "topic": "General",
    "question": "3. Recursion is well-suited for solving problems that exhibit a:",
    "options": [
      "Linear structure",
      "Hierarchical structure",
      "Random structure",
      "Circular structure"
    ],
    "answer": "Hierarchical structure"
  },
  {
    "id": 214,
    "topic": "General",
    "question": "4. In which of the following scenarios would recursion be an appropriate choice?",
    "options": [
      "Calculating the sum of elements in an array using a loop",
      "Traversing a linked list in reverse using a loop",
      "Implementing a search algorithm for a sorted array",
      "Sorting elements in an array using the Bubble Sort algorithm"
    ],
    "answer": "Traversing a linked list in reverse using a loop"
  },
  {
    "id": 215,
    "topic": "General",
    "question": "5. One of the limitations of recursion is that it may lead to:",
    "options": [
      "Slower execution of code",
      "Reduced readability of code",
      "Excessive memory consumption",
      "Inability to handle complex problems"
    ],
    "answer": "Excessive memory consumption"
  },
  {
    "id": 216,
    "topic": "General",
    "question": "6. Recursive algorithms can be more intuitive to understand for problems that have a:",
    "options": [
      "Linear structure",
      "Hierarchical structure",
      "Random structure",
      "Circular structure"
    ],
    "answer": "Hierarchical structure"
  },
  {
    "id": 217,
    "topic": "General",
    "question": "7. The use of recursion can make the code more:",
    "options": [
      "Complex and error-prone",
      "Concise and readable",
      "Dependent on external libraries",
      "Dependent on hardware specifications"
    ],
    "answer": "Concise and readable"
  },
  {
    "id": 218,
    "topic": "General",
    "question": "8. Which of the following statements is true regarding recursion and iteration?",
    "options": [
      "Recursion is always more efficient than iteration",
      "Iteration is always more efficient than recursion",
      "Recursion and iteration have similar efficiency in most cases",
      "The efficiency of recursion and iteration depends on the problem being solved"
    ],
    "answer": "The efficiency of recursion and iteration depends on the problem being solved"
  },
  {
    "id": 219,
    "topic": "General",
    "question": "9. Recursion is widely used in solving problems related to:",
    "options": [
      "String manipulation",
      "Arithmetic operations",
      "Graphics rendering",
      "Network communication"
    ],
    "answer": "String manipulation"
  },
  {
    "id": 220,
    "topic": "General",
    "question": "10. A drawback of recursion is that it may lead to a:",
    "options": [
      "Simplified problem-solving process",
      "Greater understanding of the problem",
      "Stack overflow error for deeply nested recursive calls",
      "Decrease in code complexity"
    ],
    "answer": "Stack overflow error for deeply nested recursive calls"
  },
  {
    "id": 221,
    "topic": "General",
    "question": "**4.6 Function Complexity During Recursion** 1. The complexity of a recursive function refers to:",
    "options": [
      "The number of recursive calls made",
      "The number of loops in the function",
      "The number of base conditions",
      "The time and space requirements of the function"
    ],
    "answer": "The time and space requirements of the function"
  },
  {
    "id": 222,
    "topic": "General",
    "question": "2. The time complexity of a recursive function is determined by:",
    "options": [
      "The number of parameters passed to the function",
      "The number of base conditions in the function",
      "The number of loops in the function",
      "The number of recursive calls and the time complexity of each call"
    ],
    "answer": "The number of recursive calls and the time complexity of each call"
  },
  {
    "id": 223,
    "topic": "General",
    "question": "3. What is the time complexity of a recursive function with multiple recursive calls and a time complexity of O(n) per call?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n^2)",
      "O(2^n)"
    ],
    "answer": "O(n^2)"
  },
  {
    "id": 224,
    "topic": "General",
    "question": "4. The space complexity of a recursive function is determined by:",
    "options": [
      "The number of parameters passed to the function",
      "The number of base conditions in the function",
      "The number of local variables and the maximum depth of the recursion",
      "The number of recursive calls and the space complexity of each call"
    ],
    "answer": "The number of local variables and the maximum depth of the recursion"
  },
  {
    "id": 225,
    "topic": "General",
    "question": "5. The space complexity of a recursive function with a time complexity of O(1) per call is:",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(2^n)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 226,
    "topic": "General",
    "question": "6. What is the impact of increasing the depth of recursion on the space complexity of a recursive function?",
    "options": [
      "The space complexity remains constant",
      "The space complexity increases linearly",
      "The space complexity increases logarithmically",
      "The space complexity decreases"
    ],
    "answer": "The space complexity increases linearly"
  },
  {
    "id": 227,
    "topic": "General",
    "question": "7. The space complexity of a recursive function with a time complexity of O(log n) per call is:",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(2^n)"
    ],
    "answer": "O(log n)"
  },
  {
    "id": 228,
    "topic": "General",
    "question": "8. The space complexity of a recursive function with a time complexity of O(2^n) per call is:",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(2^n)"
    ],
    "answer": "O(2^n)"
  },
  {
    "id": 229,
    "topic": "General",
    "question": "9. Recursive functions that involve backtracking or multiple recursive calls may have:",
    "options": [
      "Low time complexity but high space complexity",
      "High time complexity but low space complexity",
      "Low time complexity and low space complexity",
      "High time complexity and high space complexity"
    ],
    "answer": "High time complexity and high space complexity"
  },
  {
    "id": 230,
    "topic": "General",
    "question": "10. The time and space complexity of a recursive function can be analyzed using techniques such as:",
    "options": [
      "Stack tracing",
      "Profiling",
      "Debugging",
      "Manual calculation"
    ],
    "answer": "Profiling"
  },
  {
    "id": 231,
    "topic": "General",
    "question": "Lecture 5: Trees & Applications **5.1 Introduction to Trees** 1. In data structures, a tree is a hierarchical data structure that consists of:",
    "options": [
      "A single node",
      "A root node and child nodes",
      "A linear sequence of nodes",
      "Only leaf nodes"
    ],
    "answer": "A root node and child nodes"
  },
  {
    "id": 232,
    "topic": "General",
    "question": "2. The topmost node in a tree is called the:",
    "options": [
      "Root node",
      "Parent node",
      "Leaf node",
      "Branch node"
    ],
    "answer": "Root node"
  },
  {
    "id": 233,
    "topic": "General",
    "question": "3. In a tree, nodes that have no children are called:",
    "options": [
      "Root nodes",
      "Internal nodes",
      "Leaf nodes",
      "Branch nodes"
    ],
    "answer": "Leaf nodes"
  },
  {
    "id": 234,
    "topic": "General",
    "question": "4. A node in a tree can have how many parent nodes?",
    "options": [
      "None",
      "One",
      "Two or more",
      "It depends on the type of tree"
    ],
    "answer": "One"
  },
  {
    "id": 235,
    "topic": "General",
    "question": "5. What is the maximum number of children that a node can have in a binary tree?",
    "options": [
      "1",
      "2",
      "3",
      "There is no maximum limit"
    ],
    "answer": "2"
  },
  {
    "id": 236,
    "topic": "General",
    "question": "6. The depth of a node in a tree is the number of edges in the path from the root node to that node. What is the depth of the root node?",
    "options": [
      "0",
      "1",
      "The depth of the root node is not defined",
      "It depends on the height of the tree"
    ],
    "answer": "0"
  },
  {
    "id": 237,
    "topic": "General",
    "question": "7. The height of a tree is the maximum depth of any node in the tree. What is the height of a tree with a single node (no children)?",
    "options": [
      "0",
      "1",
      "The height is not defined for a tree with a single node",
      "It depends on the type of tree"
    ],
    "answer": "0"
  },
  {
    "id": 238,
    "topic": "General",
    "question": "8. What is a forest in the context of trees?",
    "options": [
      "A tree with a large number of nodes",
      "A collection of disjoint trees",
      "A tree with multiple root nodes",
      "A tree with no parent node"
    ],
    "answer": "A collection of disjoint trees"
  },
  {
    "id": 239,
    "topic": "General",
    "question": "**5.2 Trees and Terminology** 1. In a binary tree, a node that has at least one child node is called:",
    "options": [
      "A leaf node",
      "An internal node",
      "A root node",
      "A branch node"
    ],
    "answer": "An internal node"
  },
  {
    "id": 240,
    "topic": "General",
    "question": "2. What is the maximum number of child nodes that an internal node can have in a binary tree?",
    "options": [
      "1",
      "2",
      "3",
      "There is no maximum limit"
    ],
    "answer": "2"
  },
  {
    "id": 241,
    "topic": "General",
    "question": "3. The total number of nodes in a binary tree with height h can be at most:",
    "options": [
      "h",
      "2^h - 1",
      "2^h",
      "h^2"
    ],
    "answer": "2^h - 1"
  },
  {
    "id": 242,
    "topic": "General",
    "question": "4. A node's sibling in a binary tree is defined as:",
    "options": [
      "Its parent node",
      "Its child node",
      "Its left child node",
      "Another node with the same parent node"
    ],
    "answer": "Another node with the same parent node"
  },
  {
    "id": 243,
    "topic": "General",
    "question": "5. A node's ancestor in a tree is any node that lies on the:",
    "options": [
      "Same level as the node",
      "Path from the root to that node",
      "Left subtree of the node",
      "Right subtree of the node"
    ],
    "answer": "Path from the root to that node"
  },
  {
    "id": 244,
    "topic": "General",
    "question": "6. A node's descendant in a tree is any node that lies in the:",
    "options": [
      "Same level as the node",
      "Path from the root to that node",
      "Left subtree of the node",
      "Right subtree of the node"
    ],
    "answer": "Left subtree of the node"
  },
  {
    "id": 245,
    "topic": "General",
    "question": "7. What is the height of a binary tree with only one node (root node)?",
    "options": [
      "0",
      "1",
      "The height is not defined for a tree with only one node",
      "It depends on the type of tree"
    ],
    "answer": "0"
  },
  {
    "id": 246,
    "topic": "General",
    "question": "8. In a binary tree, the nodes at the same level are also called:",
    "options": [
      "Siblings",
      "Ancestors",
      "Descendants",
      "Cousins"
    ],
    "answer": "Siblings"
  },
  {
    "id": 247,
    "topic": "General",
    "question": "**5.3 Tree Traversals** 1. Which tree traversal visits the root node first, then the left subtree, and finally the right subtree?",
    "options": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ],
    "answer": "Preorder traversal"
  },
  {
    "id": 248,
    "topic": "General",
    "question": "2. In an inorder traversal of a binary tree, the nodes are visited in:",
    "options": [
      "Left-to-right order",
      "Right-to-left order",
      "Random order",
      "Level-order"
    ],
    "answer": "Left-to-right order"
  },
  {
    "id": 249,
    "topic": "General",
    "question": "3. What is the sequence of nodes visited during a postorder traversal of a binary tree?",
    "options": [
      "Root, left subtree, right subtree",
      "Left subtree, right subtree, root",
      "Right subtree, root, left subtree",
      "Left subtree, root, right subtree"
    ],
    "answer": "Left subtree, right subtree, root"
  },
  {
    "id": 250,
    "topic": "General",
    "question": "4. Which traversal is commonly used to delete nodes from a binary search tree?",
    "options": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ],
    "answer": "Inorder traversal"
  },
  {
    "id": 251,
    "topic": "General",
    "question": "5. Level-order traversal of a tree visits the nodes:",
    "options": [
      "From the root towards the leaves",
      "From the leaves towards the root",
      "In a zigzag manner",
      "In ascending order of their levels"
    ],
    "answer": "From the root towards the leaves"
  },
  {
    "id": 252,
    "topic": "General",
    "question": "6. What is the time complexity of performing an inorder traversal of a binary tree with n nodes?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n^2)",
      "O(2^n)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 253,
    "topic": "General",
    "question": "7. The level-order traversal of a binary tree is implemented using a:",
    "options": [
      "Depth-first search (DFS) algorithm",
      "Breadth-first search (BFS) algorithm",
      "Preorder traversal algorithm",
      "Postorder traversal algorithm"
    ],
    "answer": "Breadth-first search (BFS) algorithm"
  },
  {
    "id": 254,
    "topic": "General",
    "question": "8. In a binary tree, which traversal is used to obtain nodes in ascending order (sorted order)?",
    "options": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ],
    "answer": "Inorder traversal"
  },
  {
    "id": 255,
    "topic": "General",
    "question": "**5.4 Binary Trees** 1. A binary tree is a tree data structure in which each node can have:",
    "options": [
      "Two children",
      "Three children",
      "More than three children",
      "Any number of children"
    ],
    "answer": "Two children"
  },
  {
    "id": 256,
    "topic": "General",
    "question": "2. In a binary tree, the node that has no parent is called the:",
    "options": [
      "Root node",
      "Leaf node",
      "Internal node",
      "Sibling node"
    ],
    "answer": "Root node"
  },
  {
    "id": 257,
    "topic": "General",
    "question": "3. A full binary tree is a binary tree in which:",
    "options": [
      "All nodes have two children, except leaf nodes",
      "All nodes have one child, except the root node",
      "All nodes have exactly two children",
      "All nodes have at least two children"
    ],
    "answer": "All nodes have two children, except leaf nodes"
  },
  {
    "id": 258,
    "topic": "General",
    "question": "4. What is the minimum height of a binary tree with n nodes?",
    "options": [
      "0",
      "1",
      "log2(n)",
      "n"
    ],
    "answer": "1"
  },
  {
    "id": 259,
    "topic": "General",
    "question": "5. A binary tree with all leaf nodes at the same level is called a:",
    "options": [
      "Full binary tree",
      "Perfect binary tree",
      "Balanced binary tree",
      "Complete binary tree"
    ],
    "answer": "Perfect binary tree"
  },
  {
    "id": 260,
    "topic": "General",
    "question": "6. A binary tree with all internal nodes having exactly one child is called a:",
    "options": [
      "Full binary tree",
      "Perfect binary tree",
      "Balanced binary tree",
      "Skewed binary tree"
    ],
    "answer": "Skewed binary tree"
  },
  {
    "id": 261,
    "topic": "General",
    "question": "7. A binary tree is considered balanced if:",
    "options": [
      "All nodes have two children",
      "The heights of the left and right subtrees differ by at most one",
      "The number of nodes is a power of two",
      "It is a complete binary tree"
    ],
    "answer": "The heights of the left and right subtrees differ by at most one"
  },
  {
    "id": 262,
    "topic": "General",
    "question": "8. What is the maximum number of nodes at level k in a binary tree?",
    "options": [
      "2^k",
      "2^(k+1) - 1",
      "k",
      "2k"
    ],
    "answer": "2^k"
  },
  {
    "id": 263,
    "topic": "General",
    "question": "**5.5 Complete Binary Trees / Almost Complete Binary Tree (ACBT)** 1. A complete binary tree is a binary tree in which:",
    "options": [
      "All nodes have two children, except leaf nodes",
      "All nodes have one child, except the root node",
      "All levels are completely filled with nodes",
      "All internal nodes have exactly one child"
    ],
    "answer": "All levels are completely filled with nodes"
  },
  {
    "id": 264,
    "topic": "General",
    "question": "2. In a complete binary tree, if a node has an index i (0-based indexing) in the level-order traversal, then its left child will have an index of:",
    "options": [
      "i - 1",
      "2i",
      "2i + 1",
      "i + 1"
    ],
    "answer": "2i + 1"
  },
  {
    "id": 265,
    "topic": "General",
    "question": "3. In a complete binary tree, if a node has an index i (0-based indexing) in the level-order traversal, then its right child will have an index of:",
    "options": [
      "i - 1",
      "2i",
      "2i + 1",
      "i + 1"
    ],
    "answer": "2i + 1"
  },
  {
    "id": 266,
    "topic": "General",
    "question": "4. In a complete binary tree with n nodes, what is the maximum height of the tree?",
    "options": [
      "log2(n)",
      "n",
      "n - 1",
      "n + 1"
    ],
    "answer": "log2(n)"
  },
  {
    "id": 267,
    "topic": "General",
    "question": "5. What is the minimum number of nodes in a complete binary tree of height h?",
    "options": [
      "2^h - 1",
      "2^h",
      "h",
      "h + 1"
    ],
    "answer": "2^h"
  },
  {
    "id": 268,
    "topic": "General",
    "question": "6. An almost complete binary tree (ACBT) is a binary tree that:",
    "options": [
      "Has all levels completely filled with nodes",
      "Is a perfect binary tree",
      "Is a full binary tree",
      "Is a complete binary tree, but some nodes are missing from the last level"
    ],
    "answer": "Is a complete binary tree, but some nodes are missing from the last level"
  },
  {
    "id": 269,
    "topic": "General",
    "question": "7. In an almost complete binary tree (ACBT), the last level may not be completely filled, but:",
    "options": [
      "All internal nodes have two children",
      "The number of nodes at each level is the same",
      "The left subtree is completely filled",
      "The right subtree is completely filled"
    ],
    "answer": "The number of nodes at each level is the same"
  },
  {
    "id": 270,
    "topic": "General",
    "question": "8. What is the key property that distinguishes an almost complete binary tree (ACBT) from a complete binary tree?",
    "options": [
      "The height of the tree",
      "The number of nodes",
      "The number of children per node",
      "The completeness of the last level"
    ],
    "answer": "The completeness of the last level"
  },
  {
    "id": 271,
    "topic": "General",
    "question": "**5.6 Array Implementation of ACBT** 1. In an array implementation of an almost complete binary tree (ACBT), if a node is at index i, what are the indices of its left child and right child, respectively?",
    "options": [
      "2i and 2i + 1",
      "i - 1 and i + 1",
      "i + 1 and i + 2",
      "i and i + 1"
    ],
    "answer": "2i and 2i + 1"
  },
  {
    "id": 272,
    "topic": "General",
    "question": "2. In an array implementation of an almost complete binary tree (ACBT), what is the index of the parent node of a node at index i?",
    "options": [
      "i / 2",
      "i - 1",
      "i + 1",
      "i * 2"
    ],
    "answer": "i / 2"
  },
  {
    "id": 273,
    "topic": "General",
    "question": "3. If an array is used to represent an almost complete binary tree (ACBT) of n nodes, what will be the size of the array?",
    "options": [
      "n",
      "n + 1",
      "2n",
      "2n + 1"
    ],
    "answer": "n"
  },
  {
    "id": 274,
    "topic": "General",
    "question": "4. In an array implementation of an almost complete binary tree (ACBT), the elements of the tree are stored in the array such that:",
    "options": [
      "All elements are stored in ascending order",
      "The root element is at the first index (index 0)",
      "The elements are stored in a zigzag manner",
      "The parent node is always greater than its children"
    ],
    "answer": "The root element is at the first index (index 0)"
  },
  {
    "id": 275,
    "topic": "General",
    "question": "5. The array implementation of an almost complete binary tree (ACBT) saves memory compared to a linked representation because:",
    "options": [
      "It requires fewer nodes to represent the tree",
      "It eliminates the need for pointers to link nodes",
      "It allows for faster tree traversal",
      "It has a smaller height"
    ],
    "answer": "It eliminates the need for pointers to link nodes"
  },
  {
    "id": 276,
    "topic": "General",
    "question": "6. In an array representation of an almost complete binary tree (ACBT), if a node is at index i, and i is greater than the size of the array, it indicates that:",
    "options": [
      "The tree is not an ACBT",
      "The node is a leaf node",
      "The node has no children",
      "The node is missing from the tree"
    ],
    "answer": "The node is missing from the tree"
  },
  {
    "id": 277,
    "topic": "General",
    "question": "7. One disadvantage of using an array to represent an almost complete binary tree (ACBT) is that:",
    "options": [
      "It requires more memory compared to linked representation",
      "It is difficult to perform insertion and deletion operations",
      "It is not possible to find the parent of a node",
      "It cannot handle trees with more than 100 nodes"
    ],
    "answer": "It is difficult to perform insertion and deletion operations"
  },
  {
    "id": 278,
    "topic": "General",
    "question": "8. When converting an ACBT into an array representation, the nodes are stored in the array in a specific order to maintain:",
    "options": [
      "Balanced height of the tree",
      "The heap property of the tree",
      "The completeness of the last level",
      "The maximum number of nodes at each level"
    ],
    "answer": "The completeness of the last level"
  },
  {
    "id": 279,
    "topic": "General",
    "question": "**5.7 Binary Search Trees** 1. In a binary search tree (BST), the key value of the left child is:",
    "options": [
      "Greater than the key value of the parent",
      "Less than the key value of the parent",
      "Equal to the key value of the parent",
      "Unrelated to the key value of the parent"
    ],
    "answer": "Less than the key value of the parent"
  },
  {
    "id": 280,
    "topic": "General",
    "question": "2. In a binary search tree (BST), the key value of the right child is:",
    "options": [
      "Greater than the key value of the parent",
      "Less than the key value of the parent",
      "Equal to the key value of the parent",
      "Unrelated to the key value of the parent"
    ],
    "answer": "Greater than the key value of the parent"
  },
  {
    "id": 281,
    "topic": "General",
    "question": "3. The binary search tree (BST) property allows for efficient searching of elements because:",
    "options": [
      "All elements are stored in a sorted order",
      "All elements have unique key values",
      "All elements have the same key value",
      "The tree is perfectly balanced"
    ],
    "answer": "All elements are stored in a sorted order"
  },
  {
    "id": 282,
    "topic": "General",
    "question": "4. In a binary search tree (BST), the minimum element is found by:",
    "options": [
      "Following the left child pointers from the root until a leaf node is reached",
      "Following the right child pointers from the root until a leaf node is reached",
      "Starting from the root and comparing key values with the left and right children",
      "Randomly searching for the minimum element"
    ],
    "answer": "Following the left child pointers from the root until a leaf node is reached"
  },
  {
    "id": 283,
    "topic": "General",
    "question": "5. In a binary search tree (BST), the maximum element is found by:",
    "options": [
      "Following the left child pointers from the root until a leaf node is reached",
      "Following the right child pointers from the root until a leaf node is reached",
      "Starting from the root and comparing key values with the left and right children",
      "Randomly searching for the maximum element"
    ],
    "answer": "Following the right child pointers from the root until a leaf node is reached"
  },
  {
    "id": 284,
    "topic": "General",
    "question": "6. Which operation is commonly used to insert a new element into a binary search tree (BST) while maintaining the BST property?",
    "options": [
      "Left rotation",
      "Right rotation",
      "Preorder traversal",
      "Binary search"
    ],
    "answer": "Binary search"
  },
  {
    "id": 285,
    "topic": "General",
    "question": "7. In a binary search tree (BST), if a node with a given key value is not found during the search operation, it indicates that:",
    "options": [
      "The tree is not balanced",
      "The tree is not an ACBT",
      "The node does not exist in the tree",
      "The tree is not sorted"
    ],
    "answer": "The node does not exist in the tree"
  },
  {
    "id": 286,
    "topic": "General",
    "question": "8. The worst-case time complexity of searching for an element in a binary search tree (BST) with n nodes is:",
    "options": [
      "O(1) b ) O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(log n)"
  },
  {
    "id": 287,
    "topic": "General",
    "question": "**5.8 AVL Tree** 1. An AVL tree is a self-balancing binary search tree, where the balance factor of every node is:",
    "options": [
      "Greater than 0",
      "Less than 0",
      "Equal to 0",
      "Between -1 and 1"
    ],
    "answer": "Between -1 and 1"
  },
  {
    "id": 288,
    "topic": "General",
    "question": "2. In an AVL tree, the balance factor of a node is defined as the difference between:",
    "options": [
      "The height of its left subtree and the height of its right subtree",
      "The number of nodes in its left subtree and the number of nodes in its right subtree",
      "The key value of its left child and the key value of its right child",
      "The depth of its left subtree and the depth of its right subtree"
    ],
    "answer": "The height of its left subtree and the height of its right subtree"
  },
  {
    "id": 289,
    "topic": "General",
    "question": "3. What operation is performed to balance an AVL tree after inserting a new node?",
    "options": [
      "Right rotation",
      "Left rotation",
      "Preorder traversal",
      "Level-order traversal"
    ],
    "answer": "Right rotation"
  },
  {
    "id": 290,
    "topic": "General",
    "question": "4. In an AVL tree, after a right rotation is performed on a node, which node becomes the new parent of the subtree?",
    "options": [
      "The left child of the node",
      "The right child of the node",
      "The parent of the node",
      "The grandparent of the node"
    ],
    "answer": "The right child of the node"
  },
  {
    "id": 291,
    "topic": "General",
    "question": "5. The height of an AVL tree with n nodes is guaranteed to be:",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(log n)"
  },
  {
    "id": 292,
    "topic": "General",
    "question": "6. In an AVL tree, after a left rotation is performed on a node, which node becomes the new parent of the subtree?",
    "options": [
      "The left child of the node",
      "The right child of the node",
      "The parent of the node",
      "The grandparent of the node"
    ],
    "answer": "The left child of the node"
  },
  {
    "id": 293,
    "topic": "General",
    "question": "7. In an AVL tree, the balancing operation is triggered when the balance factor of a node becomes:",
    "options": [
      "0",
      "1",
      "-1",
      "Outside the range of -1 to 1"
    ],
    "answer": "Outside the range of -1 to 1"
  },
  {
    "id": 294,
    "topic": "General",
    "question": "8. The main advantage of using AVL trees over regular binary search trees is that AVL trees:",
    "options": [
      "Have faster search operations",
      "Require less memory",
      "Support more operations",
      "Ensure a balanced height, resulting in faster overall operations"
    ],
    "answer": "Ensure a balanced height, resulting in faster overall operations"
  },
  {
    "id": 295,
    "topic": "General",
    "question": "**5.9 Multi-way Tree** 1. A multi-way tree is a tree in which each internal node can have:",
    "options": [
      "One child",
      "Two children",
      "Multiple children",
      "Only leaf nodes"
    ],
    "answer": "Multiple children"
  },
  {
    "id": 296,
    "topic": "General",
    "question": "2. In a multi-way tree, the number of children a node can have is called the:",
    "options": [
      "Degree of the node",
      "Height of the node",
      "Level of the node",
      "Depth of the node"
    ],
    "answer": "Degree of the node"
  },
  {
    "id": 297,
    "topic": "General",
    "question": "3. The term \"m-ary tree\" is used to describe a multi-way tree in which:",
    "options": [
      "All internal nodes have m children",
      "All leaf nodes have m children",
      "The root node has m children",
      "The tree has exactly m levels"
    ],
    "answer": "All internal nodes have m children"
  },
  {
    "id": 298,
    "topic": "General",
    "question": "4. A binary tree is a special case of a multi-way tree where each internal node has:",
    "options": [
      "One child",
      "Two children",
      "Three children",
      "Multiple children"
    ],
    "answer": "Two children"
  },
  {
    "id": 299,
    "topic": "General",
    "question": "5. In a ternary tree, each internal node has:",
    "options": [
      "One child",
      "Two children",
      "Three children",
      "Multiple children"
    ],
    "answer": "Three children"
  },
  {
    "id": 300,
    "topic": "General",
    "question": "6. The height of a multi-way tree is the:",
    "options": [
      "Number of levels in the tree",
      "Number of nodes in the tree",
      "Number of children of the root node",
      "Number of leaf nodes in the tree"
    ],
    "answer": "Number of levels in the tree"
  },
  {
    "id": 301,
    "topic": "General",
    "question": "7. A multi-way tree with all internal nodes having the same number of children is called a:",
    "options": [
      "Full multi-way tree",
      "Perfect multi-way tree",
      "Balanced multi-way tree",
      "Complete multi-way tree"
    ],
    "answer": "Full multi-way tree"
  },
  {
    "id": 302,
    "topic": "General",
    "question": "8. In a multi-way tree, the number of children of a node is called the:",
    "options": [
      "Degree of the node",
      "Height of the node",
      "Level of the node",
      "Depth of the node"
    ],
    "answer": "Degree of the node"
  },
  {
    "id": 303,
    "topic": "General",
    "question": "**5.10 Brief Introduction and Uses Cases of B-Tree / B+Tree** 1. A B-tree is a self-balancing multi-way search tree that is commonly used in:",
    "options": [
      "Database indexing",
      "Artificial intelligence",
      "Graph algorithms",
      "Image processing"
    ],
    "answer": "Database indexing"
  },
  {
    "id": 304,
    "topic": "General",
    "question": "2. In a B-tree, each node can have:",
    "options": [
      "One child",
      "Two children",
      "Multiple children",
      "Only leaf nodes"
    ],
    "answer": "Multiple children"
  },
  {
    "id": 305,
    "topic": "General",
    "question": "3. The main advantage of using B-trees in database indexing is that B-trees:",
    "options": [
      "Have a fixed height",
      "Require less memory",
      "Ensure fast search and insertion operations on disk",
      "Allow for efficient depth-first search"
    ],
    "answer": "Ensure fast search and insertion operations on disk"
  },
  {
    "id": 306,
    "topic": "General",
    "question": "4. B-trees are used to maintain:",
    "options": [
      "Sorted arrays",
      "Sorted linked lists",
      "Sorted binary trees",
      "Sorted sequences of records on disk"
    ],
    "answer": "Sorted sequences of records on disk"
  },
  {
    "id": 307,
    "topic": "General",
    "question": "5. In a B+ tree, all the data records are stored in:",
    "options": [
      "Internal nodes",
      "Leaf nodes",
      "The root node",
      "The parent node"
    ],
    "answer": "Leaf nodes"
  },
  {
    "id": 308,
    "topic": "General",
    "question": "6. The main advantage of using B+ trees over B-trees is that B+ trees:",
    "options": [
      "Have a smaller height",
      "Support faster search operations",
      "Allow for dynamic changes in degree",
      "Use less memory"
    ],
    "answer": "Support faster search operations"
  },
  {
    "id": 309,
    "topic": "General",
    "question": "7. B-trees and B+ trees are particularly well-suited for use in databases because they:",
    "options": [
      "Minimize the use of disk storage",
      "Provide a constant-time search operation",
      "Balance the tree automatically",
      "Support efficient range queries and ordered traversals"
    ],
    "answer": "Support efficient range queries and ordered traversals"
  },
  {
    "id": 310,
    "topic": "General",
    "question": "8. B-trees and B+ trees are commonly used in scenarios where data is stored on secondary storage devices like hard disks because they:",
    "options": [
      "Reduce the number of disk accesses",
      "Minimize the use of main memory",
      "Support parallel processing",
      "Allow for faster processing of complex algorithms"
    ],
    "answer": "Reduce the number of disk accesses"
  },
  {
    "id": 311,
    "topic": "General",
    "question": "Lecture 6: Searching & Sorting Algorithms **6.1 Objectives of Searching** 1. What is the primary objective of searching algorithms?",
    "options": [
      "To sort the data in ascending order",
      "To find the minimum value in a list",
      "To locate a specific item in a collection of data",
      "To count the total number of elements in an array"
    ],
    "answer": "To locate a specific item in a collection of data"
  },
  {
    "id": 312,
    "topic": "General",
    "question": "2. What is the time complexity of the sequential search algorithm in the worst case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 313,
    "topic": "General",
    "question": "3. The sequential search algorithm is best suited for searching in which type of data structure?",
    "options": [
      "Sorted arrays",
      "Linked lists",
      "Binary search trees",
      "Hash tables"
    ],
    "answer": "Linked lists"
  },
  {
    "id": 314,
    "topic": "General",
    "question": "4. What is the primary disadvantage of the sequential search algorithm?",
    "options": [
      "It can only search for integers",
      "It requires the data to be in sorted order",
      "It has a high time complexity for large datasets",
      "It can only be used with arrays"
    ],
    "answer": "It has a high time complexity for large datasets"
  },
  {
    "id": 315,
    "topic": "General",
    "question": "5. In the sequential search algorithm, if the target element is found early in the list, what is the best- case time complexity?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 316,
    "topic": "General",
    "question": "6. The binary search algorithm requires the input data to be in:",
    "options": [
      "Ascending order",
      "Descending order",
      "Random order",
      "Any order"
    ],
    "answer": "Ascending order"
  },
  {
    "id": 317,
    "topic": "General",
    "question": "**6.1.1 The Sequential Search** 1. The sequential search algorithm starts searching for the target element from the:",
    "options": [
      "Last element of the list",
      "Middle element of the list",
      "First element of the list",
      "Randomly selected element of the list"
    ],
    "answer": "First element of the list"
  },
  {
    "id": 318,
    "topic": "General",
    "question": "2. The sequential search algorithm compares the target element with each element in the list until:",
    "options": [
      "It finds the target element",
      "It reaches the middle element of the list",
      "The list becomes empty",
      "It reaches the last element of the list"
    ],
    "answer": "It finds the target element"
  },
  {
    "id": 319,
    "topic": "General",
    "question": "3. What is the worst-case time complexity of the sequential search algorithm?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 320,
    "topic": "General",
    "question": "4. If the target element is not present in the list, the sequential search algorithm will:",
    "options": [
      "Output the index of the target element as -1",
      "Output the index of the target element as 0",
      "Return an empty list",
      "Iterate through the entire list without finding the target element"
    ],
    "answer": "Iterate through the entire list without finding the target element"
  },
  {
    "id": 321,
    "topic": "General",
    "question": "5. The sequential search algorithm is an example of a:",
    "options": [
      "Divide and conquer algorithm",
      "Greedy algorithm",
      "Recursive algorithm",
      "Linear search algorithm"
    ],
    "answer": "Linear search algorithm"
  },
  {
    "id": 322,
    "topic": "General",
    "question": "6.1.2 Analysis of Sequential Search 1. The time complexity of the sequential search algorithm in the best-case scenario is:",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 323,
    "topic": "General",
    "question": "2. In the worst-case scenario, when the target element is not present in the list, the sequential search algorithm will perform how many comparisons?",
    "options": [
      "1",
      "n",
      "n/2",
      "n-1"
    ],
    "answer": "n-1"
  },
  {
    "id": 324,
    "topic": "General",
    "question": "3. The sequential search algorithm is efficient for searching in:",
    "options": [
      "Sorted arrays",
      "Linked lists",
      "Binary search trees",
      "Hash tables"
    ],
    "answer": "Linked lists"
  },
  {
    "id": 325,
    "topic": "General",
    "question": "4. The time complexity of the sequential search algorithm in the average-case scenario is:",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 326,
    "topic": "General",
    "question": "5. The sequential search algorithm works well for small datasets because of its:",
    "options": [
      "Low space complexity",
      "Low time complexity",
      "Ease of implementation",
      "Recursive nature"
    ],
    "answer": "Ease of implementation"
  },
  {
    "id": 327,
    "topic": "General",
    "question": "6. The sequential search algorithm is classified as a:",
    "options": [
      "Recursive algorithm",
      "Divide and conquer algorithm",
      "Linear search algorithm",
      "Greedy algorithm"
    ],
    "answer": "Linear search algorithm"
  },
  {
    "id": 328,
    "topic": "General",
    "question": "**6.1.3 The Binary Search** 1. The binary search algorithm is applicable only to:",
    "options": [
      "Sorted arrays",
      "Linked lists",
      "Hash tables",
      "Binary search trees"
    ],
    "answer": "Sorted arrays"
  },
  {
    "id": 329,
    "topic": "General",
    "question": "2. The binary search algorithm divides the input data into two halves and compares the target element with the:",
    "options": [
      "Middle element of the array",
      "First element of the array",
      "Last element of the array",
      "Randomly selected element of the array"
    ],
    "answer": "Middle element of the array"
  },
  {
    "id": 330,
    "topic": "General",
    "question": "3. In each step of the binary search algorithm, half of the remaining elements are:",
    "options": [
      "Removed from the search",
      "Duplicated for further search",
      "Sorted in ascending order",
      "Compared with the target element"
    ],
    "answer": "Removed from the search"
  },
  {
    "id": 331,
    "topic": "General",
    "question": "4. If the target element is found during the binary search algorithm, it will be at the:",
    "options": [
      "First index of the array",
      "Last index of the array",
      "Middle index of the array",
      "Any index of the array"
    ],
    "answer": "Middle index of the array"
  },
  {
    "id": 332,
    "topic": "General",
    "question": "5. What is the time complexity of the binary search algorithm in the worst case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(log n)"
  },
  {
    "id": 333,
    "topic": "General",
    "question": "6. In the binary search algorithm, if the target element is greater than the middle element of the array, the search continues in the:",
    "options": [
      "Left half of the array",
      "Right half of the array",
      "Middle element of the array",
      "Any random half of the array"
    ],
    "answer": "Right half of the array"
  },
  {
    "id": 334,
    "topic": "General",
    "question": "**6.2 Analysis of Binary Search** 1. The time complexity of the binary search algorithm in the best-case scenario is:",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(log n)"
  },
  {
    "id": 335,
    "topic": "General",
    "question": "2. In the worst-case scenario, when the target element is not present in the sorted array, the binary search algorithm will perform how many comparisons?",
    "options": [
      "1",
      "log n",
      "n",
      "n/2"
    ],
    "answer": "log n"
  },
  {
    "id": 336,
    "topic": "General",
    "question": "3. The binary search algorithm is efficient for searching in:",
    "options": [
      "Unsorted arrays b ) Linked lists",
      "Hash tables",
      "Sorted arrays"
    ],
    "answer": "Sorted arrays"
  },
  {
    "id": 337,
    "topic": "General",
    "question": "4. The time complexity of the binary search algorithm in the average-case scenario is:",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(log n)"
  },
  {
    "id": 338,
    "topic": "General",
    "question": "5. The binary search algorithm works well for large datasets because of its:",
    "options": [
      "Low space complexity",
      "Low time complexity",
      "Ease of implementation",
      "Recursive nature"
    ],
    "answer": "Low time complexity"
  },
  {
    "id": 339,
    "topic": "General",
    "question": "6. The binary search algorithm is classified as a:",
    "options": [
      "Recursive algorithm",
      "Divide and conquer algorithm",
      "Linear search algorithm",
      "Greedy algorithm"
    ],
    "answer": "Divide and conquer algorithm"
  },
  {
    "id": 340,
    "topic": "General",
    "question": "**6.3 Introduction to Sorting** 1. Sorting is the process of arranging elements in:",
    "options": [
      "Random order",
      "Ascending order",
      "Descending order",
      "Any order"
    ],
    "answer": "Ascending order"
  },
  {
    "id": 341,
    "topic": "General",
    "question": "2. Which of the following is not an example of a sorting algorithm?",
    "options": [
      "QuickSort",
      "Bubble Sort",
      "Depth-First Search (DFS)",
      "Merge Sort"
    ],
    "answer": "Depth-First Search (DFS)"
  },
  {
    "id": 342,
    "topic": "General",
    "question": "3. Sorting algorithms are commonly used in various applications, including:",
    "options": [
      "Database management systems",
      "Image processing",
      "Data compression",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "id": 343,
    "topic": "General",
    "question": "4. The time complexity of a sorting algorithm is primarily measured by the number of:",
    "options": [
      "Comparisons and swaps performed",
      "Loops used in the algorithm",
      "Recursion calls made",
      "Random choices made during the process"
    ],
    "answer": "Comparisons and swaps performed"
  },
  {
    "id": 344,
    "topic": "General",
    "question": "5. In a stable sorting algorithm, elements with equal keys maintain their relative order in the:",
    "options": [
      "Original array",
      "Final sorted array",
      "Middle of the array",
      "Random positions in the array"
    ],
    "answer": "Final sorted array"
  },
  {
    "id": 345,
    "topic": "General",
    "question": "6.3.1 Selection Sort 1. The selection sort algorithm works by repeatedly finding the:",
    "options": [
      "Smallest element in the unsorted part of the array",
      "Largest element in the unsorted part of the array",
      "Middle element in the unsorted part of the array",
      "Randomly selected element in the unsorted part of the array"
    ],
    "answer": "Smallest element in the unsorted part of the array"
  },
  {
    "id": 346,
    "topic": "General",
    "question": "2. In each iteration of the selection sort algorithm, the selected smallest element is placed at the:",
    "options": [
      "Beginning of the array",
      "End of the array",
      "Middle of the array",
      "Random position in the array"
    ],
    "answer": "Beginning of the array"
  },
  {
    "id": 347,
    "topic": "General",
    "question": "3. What is the time complexity of the selection sort algorithm in the best case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n^2)"
  },
  {
    "id": 348,
    "topic": "General",
    "question": "4. Selection sort is an example of a:",
    "options": [
      "Divide and conquer algorithm",
      "Greedy algorithm",
      "Recursive algorithm",
      "Linear search algorithm"
    ],
    "answer": "Greedy algorithm"
  },
  {
    "id": 349,
    "topic": "General",
    "question": "5. The selection sort algorithm is not suitable for sorting large datasets because of its:",
    "options": [
      "Low time complexity",
      "Low space complexity",
      "High time complexity",
      "High space complexity"
    ],
    "answer": "High time complexity"
  },
  {
    "id": 350,
    "topic": "General",
    "question": "6. In the selection sort algorithm, the number of comparisons performed is:",
    "options": [
      "Equal to the number of elements in the array",
      "Equal to half of the number of elements in the array",
      "Equal to the number of inversions in the array",
      "Equal to the square of the number of elements in the array"
    ],
    "answer": "Equal to the square of the number of elements in the array"
  },
  {
    "id": 351,
    "topic": "General",
    "question": "**6.3.2 Insertion Sort** 1. The insertion sort algorithm works by dividing the input array into:",
    "options": [
      "Two equal halves",
      "Two sorted and unsorted parts",
      "Three equal parts",
      "Multiple subarrays"
    ],
    "answer": "Two sorted and unsorted parts"
  },
  {
    "id": 352,
    "topic": "General",
    "question": "2. In each iteration of the insertion sort algorithm, the algorithm picks an element from the unsorted part and places it in the correct position within the:",
    "options": [
      "Unsorted part of the array",
      "Sorted part of the array",
      "Middle of the array",
      "Random position in the array"
    ],
    "answer": "Sorted part of the array"
  },
  {
    "id": 353,
    "topic": "General",
    "question": "3. What is the time complexity of the insertion sort algorithm in the best case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 354,
    "topic": "General",
    "question": "4. Insertion sort is an example of a:",
    "options": [
      "Divide and conquer algorithm",
      "Greedy algorithm",
      "Recursive algorithm",
      "Linear search algorithm"
    ],
    "answer": "Linear search algorithm"
  },
  {
    "id": 355,
    "topic": "General",
    "question": "5. The insertion sort algorithm is well-suited for:",
    "options": [
      "Sorting linked lists",
      "Sorting large datasets",
      "Sorting arrays with a small number of elements",
      "Sorting arrays in descending order"
    ],
    "answer": "Sorting linked lists"
  },
  {
    "id": 356,
    "topic": "General",
    "question": "6. In the insertion sort algorithm, the number of swaps performed is:",
    "options": [
      "Equal to the number of elements in the array",
      "Equal to half of the number of elements in the array",
      "Equal to the number of inversions in the array",
      "Equal to the square of the number of elements in the array"
    ],
    "answer": "Equal to the number of inversions in the array"
  },
  {
    "id": 357,
    "topic": "General",
    "question": "**6.3.3 Bubble Sort** 1. The bubble sort algorithm works by repeatedly comparing adjacent elements and swapping them if they are in:",
    "options": [
      "Random order",
      "Ascending order",
      "Descending order",
      "Any order"
    ],
    "answer": "Descending order"
  },
  {
    "id": 358,
    "topic": "General",
    "question": "2. In each iteration of the bubble sort algorithm, the largest element \"bubbles up\" to the:",
    "options": [
      "Beginning of the array",
      "End of the array",
      "Middle of the array",
      "Random position in the array"
    ],
    "answer": "End of the array"
  },
  {
    "id": 359,
    "topic": "General",
    "question": "3. What is the time complexity of the bubble sort algorithm in the best case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 360,
    "topic": "General",
    "question": "4. Bubble sort is an example of a:",
    "options": [
      "Divide and conquer algorithm",
      "Greedy algorithm",
      "Recursive algorithm",
      "Linear search algorithm"
    ],
    "answer": "Linear search algorithm"
  },
  {
    "id": 361,
    "topic": "General",
    "question": "5. The bubble sort algorithm is well-suited for:",
    "options": [
      "Sorting large datasets",
      "Sorting arrays with a small number of elements",
      "Sorting linked lists",
      "Sorting arrays in descending order"
    ],
    "answer": "Sorting arrays with a small number of elements"
  },
  {
    "id": 362,
    "topic": "General",
    "question": "6. In the bubble sort algorithm, the number of comparisons performed is:",
    "options": [
      "Equal to the number of elements in the array",
      "Equal to half of the number of elements in the array",
      "Equal to the number of inversions in the array",
      "Equal to the square of the number of elements in the array"
    ],
    "answer": "Equal to the square of the number of elements in the array"
  },
  {
    "id": 363,
    "topic": "General",
    "question": "**6.3.4 Heapsort** 1. Heapsort is a sorting algorithm based on:",
    "options": [
      "Merge of two sorted arrays",
      "Divide and conquer approach",
      "Building and maintaining a heap data structure",
      "Random swapping of elements"
    ],
    "answer": "Building and maintaining a heap data structure"
  },
  {
    "id": 364,
    "topic": "General",
    "question": "2. The heap data structure used in heapsort is a:",
    "options": [
      "Balanced binary search tree",
      "Complete binary tree",
      "Linked list",
      "Hash table"
    ],
    "answer": "Complete binary tree"
  },
  {
    "id": 365,
    "topic": "General",
    "question": "3. In heapsort, the largest element is repeatedly removed from the heap and placed at the:",
    "options": [
      "Root of the heap",
      "Leaf of the heap",
      "Middle of the heap",
      "Random position in the heap"
    ],
    "answer": "Root of the heap"
  },
  {
    "id": 366,
    "topic": "General",
    "question": "4. What is the time complexity of the heapsort algorithm in the best case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 367,
    "topic": "General",
    "question": "5. Heapsort is an example of a:",
    "options": [
      "Divide and conquer algorithm",
      "Greedy algorithm",
      "Recursive algorithm",
      "Linear search algorithm"
    ],
    "answer": "Divide and conquer algorithm"
  },
  {
    "id": 368,
    "topic": "General",
    "question": "6. In the heapsort algorithm, the number of swaps performed is:",
    "options": [
      "Equal to the number of elements in the array",
      "Equal to half of the number of elements in the array",
      "Equal to the number of inversions in the array",
      "Equal to the height of the heap"
    ],
    "answer": "Equal to the number of inversions in the array"
  },
  {
    "id": 369,
    "topic": "General",
    "question": "**6.3.5 Mergesort** 1. Mergesort is a sorting algorithm based on:",
    "options": [
      "Divide and conquer approach",
      "Building and maintaining a heap data structure",
      "Random swapping of elements",
      "Sequential search of elements"
    ],
    "answer": "Divide and conquer approach"
  },
  {
    "id": 370,
    "topic": "General",
    "question": "2. In mergesort, the input array is divided into smaller subarrays until each subarray contains:",
    "options": [
      "One element",
      "Two elements",
      "Three elements",
      "Four elements"
    ],
    "answer": "One element"
  },
  {
    "id": 371,
    "topic": "General",
    "question": "3. The process of combining two sorted subarrays into a single sorted array is called:",
    "options": [
      "Merge",
      "Split",
      "Heapify",
      "Swap"
    ],
    "answer": "Merge"
  },
  {
    "id": 372,
    "topic": "General",
    "question": "4. What is the time complexity of the mergesort algorithm in the best case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 373,
    "topic": "General",
    "question": "5. Mergesort is an example of a:",
    "options": [
      "Divide and conquer algorithm",
      "Greedy algorithm",
      "Recursive algorithm",
      "Linear search algorithm"
    ],
    "answer": "Divide and conquer algorithm"
  },
  {
    "id": 374,
    "topic": "General",
    "question": "6. In the mergesort algorithm, the number of comparisons performed is:",
    "options": [
      "Equal to the number of elements in the array",
      "Equal to half of the number of elements in the array",
      "Equal to the number of inversions in the array",
      "Equal to the height of the tree"
    ],
    "answer": "Equal to the number of elements in the array"
  },
  {
    "id": 375,
    "topic": "General",
    "question": "**6.3.6 Quicksort** 1. Quicksort is a sorting algorithm based on:",
    "options": [
      "Merge of two sorted arrays",
      "Divide and conquer approach",
      "Building and maintaining a heap data structure",
      "Random swapping of elements"
    ],
    "answer": "Divide and conquer approach"
  },
  {
    "id": 376,
    "topic": "General",
    "question": "2. In quicksort, the input array is partitioned into two subarrays such that elements in one subarray are:",
    "options": [
      "Smaller than the pivot element",
      "Greater than the pivot element",
      "Equal to the pivot element",
      "In random order with respect to the pivot element"
    ],
    "answer": "Smaller than the pivot element"
  },
  {
    "id": 377,
    "topic": "General",
    "question": "3. The pivot element in quicksort is usually chosen as the:",
    "options": [
      "First element of the array",
      "Middle element of the array",
      "Last element of the array",
      "Randomly selected element of the array"
    ],
    "answer": "Last element of the array"
  },
  {
    "id": 378,
    "topic": "General",
    "question": "4. What is the time complexity of the quicksort algorithm in the best case?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ],
    "answer": "O(n)"
  },
  {
    "id": 379,
    "topic": "General",
    "question": "5. Quicksort is an example of a:",
    "options": [
      "Divide and conquer algorithm",
      "Greedy algorithm",
      "Recursive algorithm",
      "Linear search algorithm"
    ],
    "answer": "Divide and conquer algorithm"
  },
  {
    "id": 380,
    "topic": "General",
    "question": "6. In the quicksort algorithm, the number of swaps performed is:",
    "options": [
      "Equal to the number of elements in the array",
      "Equal to half of the number of elements in the array",
      "Equal to the number of inversions in the array",
      "Equal to the height of the recursion tree"
    ],
    "answer": "Equal to the number of inversions in the array"
  },
  {
    "id": 381,
    "topic": "General",
    "question": "**6.4 Analysis of Sorting Algorithms** 1. The time complexity of sorting algorithms is generally expressed in terms of the number of:",
    "options": [
      "Swaps performed",
      "Loops used in the algorithm",
      "Comparisons performed",
      "Recursive calls made"
    ],
    "answer": "Comparisons performed"
  },
  {
    "id": 382,
    "topic": "General",
    "question": "2. Which sorting algorithm has the lowest time complexity in the best-case scenario?",
    "options": [
      "Selection sort",
      "Bubble sort",
      "Quick sort",
      "Merge sort"
    ],
    "answer": "Quick sort"
  },
  {
    "id": 383,
    "topic": "General",
    "question": "3. A stable sorting algorithm maintains the relative order of elements with equal keys in the:",
    "options": [
      "Original array",
      "Final sorted array",
      "Middle of the array",
      "Random positions in the array"
    ],
    "answer": "Final sorted array"
  },
  {
    "id": 384,
    "topic": "General",
    "question": "4. Which of the following sorting algorithms is not an example of a comparison-based sorting algorithm?",
    "options": [
      "Insertion sort",
      "Counting sort",
      "Quick sort",
      "Merge sort"
    ],
    "answer": "Counting sort"
  },
  {
    "id": 385,
    "topic": "General",
    "question": "5. The worst-case time complexity of a sorting algorithm gives the upper bound on the time required to sort the data when the data is:",
    "options": [
      "Sorted in ascending order",
      "Sorted in descending order",
      "Sorted in any order",
      "Sorted in reverse order"
    ],
    "answer": "Sorted in descending order"
  },
  {
    "id": 386,
    "topic": "General",
    "question": "6.4.1 Selection Sort 1. The selection sort algorithm has a time complexity of O(n^2) in both the best and worst cases.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 387,
    "topic": "General",
    "question": "2. Selection sort is an example of a stable sorting algorithm.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 388,
    "topic": "General",
    "question": "3. Selection sort works well for large datasets due to its efficient time complexity.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 389,
    "topic": "General",
    "question": "4. The main advantage of selection sort is its low space complexity.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 390,
    "topic": "General",
    "question": "5. The number of swaps performed by selection sort is proportional to the number of elements in the array.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 391,
    "topic": "General",
    "question": "6.4.2 Insertion Sort 1. The insertion sort algorithm has a time complexity of O(n) in the best case.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 392,
    "topic": "General",
    "question": "2. Insertion sort is an example of a stable sorting algorithm.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 393,
    "topic": "General",
    "question": "3. Insertion sort is well-suited for sorting linked lists due to its low time complexity.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 394,
    "topic": "General",
    "question": "4. The number of comparisons performed by insertion sort is proportional to the number of elements in the array.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 395,
    "topic": "General",
    "question": "5. The main advantage of insertion sort is its efficient performance on large datasets.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 396,
    "topic": "General",
    "question": "6.4.3 Bubble Sort 1. The bubble sort algorithm has a time complexity of O(n^2) in the best case.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 397,
    "topic": "General",
    "question": "2. Bubble sort is an example of a stable sorting algorithm.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 398,
    "topic": "General",
    "question": "3. Bubble sort is well-suited for sorting arrays with a small number of elements due to its low time complexity.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 399,
    "topic": "General",
    "question": "4. The number of swaps performed by bubble sort is proportional to the number of elements in the array.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 400,
    "topic": "General",
    "question": "5. The main advantage of bubble sort is its efficient performance on large datasets.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 401,
    "topic": "General",
    "question": "6.4.4 Heapsort 1. The heapsort algorithm has a time complexity of O(n log n) in the best case.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 402,
    "topic": "General",
    "question": "2. Heapsort is an example of a stable sorting algorithm.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 403,
    "topic": "General",
    "question": "3. Heapsort is well-suited for sorting linked lists due to its low time complexity.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 404,
    "topic": "General",
    "question": "4. The number of comparisons performed by heapsort is proportional to the number of elements in the array.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 405,
    "topic": "General",
    "question": "5. The main advantage of heapsort is its efficient performance on large datasets.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 406,
    "topic": "General",
    "question": "6.4.5 Mergesort 1. The mergesort algorithm has a time complexity of O(n log n) in the best case.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 407,
    "topic": "General",
    "question": "2. Mergesort is an example of a stable sorting algorithm.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 408,
    "topic": "General",
    "question": "3. Mergesort is well-suited for sorting arrays with a small number of elements due to its low time complexity.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 409,
    "topic": "General",
    "question": "4. The number of swaps performed by mergesort is proportional to the number of elements in the array.",
    "options": [
      "True",
      "False"
    ],
    "answer": "False"
  },
  {
    "id": 410,
    "topic": "General",
    "question": "5. The main advantage of mergesort is its efficient performance on large datasets.",
    "options": [
      "True",
      "False"
    ],
    "answer": "True"
  },
  {
    "id": 411,
    "topic": "General",
    "question": "Lecture 7: Hash Functions and Hash Tables **7.1 Hashing & Introduction to Hash Tables** 1. Hashing is a technique used to:",
    "options": [
      "Sort elements in ascending order",
      "Retrieve data from a database",
      "Map data to a fixed-size array",
      "Create linked lists"
    ],
    "answer": "Map data to a fixed-size array"
  },
  {
    "id": 412,
    "topic": "General",
    "question": "2. Hashing is commonly used to improve the efficiency of:",
    "options": [
      "Sorting algorithms",
      "Searching algorithms",
      "Recursive algorithms",
      "Greedy algorithms"
    ],
    "answer": "Searching algorithms"
  },
  {
    "id": 413,
    "topic": "General",
    "question": "3. The data structure that uses hashing to store and retrieve data is called a:",
    "options": [
      "Linked list",
      "Binary tree",
      "Hash table",
      "Stack"
    ],
    "answer": "Hash table"
  },
  {
    "id": 414,
    "topic": "General",
    "question": "4. The purpose of a hash function is to:",
    "options": [
      "Generate random numbers",
      "Convert data into a unique numeric value",
      "Sort data in ascending order",
      "Merge two arrays"
    ],
    "answer": "Convert data into a unique numeric value"
  },
  {
    "id": 415,
    "topic": "General",
    "question": "5. Hash tables use an array to store data, and the array index is determined by the hash function. What is the term used for the array index?",
    "options": [
      "Hash value",
      "Hash key",
      "Hash code",
      "Hash index"
    ],
    "answer": "Hash index"
  },
  {
    "id": 416,
    "topic": "General",
    "question": "6. In hashing, what is the name given to the process of converting a key into its corresponding hash value/index?",
    "options": [
      "Hashing",
      "Collision resolution",
      "Hash function",
      "Hashing algorithm"
    ],
    "answer": "Hash function"
  },
  {
    "id": 417,
    "topic": "General",
    "question": "7. Which of the following is NOT a common application of hashing?",
    "options": [
      "Cryptography",
      "Spell-checking",
      "Database indexing",
      "Sorting"
    ],
    "answer": "Sorting"
  },
  {
    "id": 418,
    "topic": "General",
    "question": "8. When two different keys generate the same hash value, it is called:",
    "options": [
      "Clustering",
      "Hash collision",
      "Hash table overflow",
      "Linear probing"
    ],
    "answer": "Hash collision"
  },
  {
    "id": 419,
    "topic": "General",
    "question": "**7.2 Hash Functions** 1. A good hash function should have the property of:",
    "options": [
      "Collisions",
      "Determinism",
      "Deterministic collisions",
      "Uniform distribution"
    ],
    "answer": "Uniform distribution"
  },
  {
    "id": 420,
    "topic": "General",
    "question": "2. The output of a hash function is typically a:",
    "options": [
      "String",
      "Float number",
      "Integer value",
      "Linked list"
    ],
    "answer": "Integer value"
  },
  {
    "id": 421,
    "topic": "General",
    "question": "3. The goal of a hash function is to minimize:",
    "options": [
      "Collisions",
      "Hash table size",
      "Uniform distribution",
      "Load factor"
    ],
    "answer": "Collisions"
  },
  {
    "id": 422,
    "topic": "General",
    "question": "4. Which of the following is not a requirement for a good hash function?",
    "options": [
      "Determinism",
      "Uniform distribution",
      "Reversibility",
      "Efficiency"
    ],
    "answer": "Reversibility"
  },
  {
    "id": 423,
    "topic": "General",
    "question": "5. Which of the following is a disadvantage of using a hash function with poor distribution properties?",
    "options": [
      "Reduced collision probability",
      "Increased load factor",
      "Slower hash table resizing",
      "Reduced memory usage"
    ],
    "answer": "Increased load factor"
  },
  {
    "id": 424,
    "topic": "General",
    "question": "6. Which of the following hash functions is more likely to cause clustering in a hash table?",
    "options": [
      "A hash function with uniform distribution",
      "A hash function that always returns the same hash value",
      "A hash function that multiplies the key by a prime number",
      "A hash function that performs bitwise XOR on the key"
    ],
    "answer": "A hash function that always returns the same hash value"
  },
  {
    "id": 425,
    "topic": "General",
    "question": "7. One approach to handling hash collisions is to use a separate data structure to store multiple values that share the same hash index. What is this data structure called?",
    "options": [
      "Linked list",
      "Binary tree",
      "Stack",
      "Queue"
    ],
    "answer": "Linked list"
  },
  {
    "id": 426,
    "topic": "General",
    "question": "8. Which of the following statements is true about hash functions?",
    "options": [
      "A perfect hash function guarantees no collisions.",
      "A perfect hash function is always efficient to compute.",
      "A perfect hash function is always reversible.",
      "A perfect hash function maps all keys to the same hash value."
    ],
    "answer": "A perfect hash function guarantees no collisions."
  },
  {
    "id": 427,
    "topic": "General",
    "question": "**7.3 Different Types of Hash Functions** 1. The division method is a type of hash function that uses:",
    "options": [
      "Bitwise operations",
      "Multiplication by a prime number",
      "Division by a prime number",
      "Exponential functions"
    ],
    "answer": "Division by a prime number"
  },
  {
    "id": 428,
    "topic": "General",
    "question": "2. The multiplication method is a type of hash function that involves:",
    "options": [
      "Multiplying the key by a prime number and taking the remainder",
      "Taking the bitwise XOR of the key and a prime number",
      "Dividing the key by a prime number and taking the quotient",
      "Adding the key and a prime number"
    ],
    "answer": "Multiplying the key by a prime number and taking the remainder"
  },
  {
    "id": 429,
    "topic": "General",
    "question": "3. The folding method is a type of hash function that:",
    "options": [
      "Involves bitwise shifting of the key",
      "Breaks the key into several parts, adds them, and takes the remainder",
      "Multiplies the key by a prime number",
      "Involves taking the bitwise OR of the key and a prime number"
    ],
    "answer": "Breaks the key into several parts, adds them, and takes the remainder"
  },
  {
    "id": 430,
    "topic": "General",
    "question": "4. The mid-square method is a type of hash function that:",
    "options": [
      "Involves taking the square root of the key",
      "Multiplies the key by itself and takes the middle digits",
      "Adds the key and a prime number",
      "Uses bitwise XOR to modify the key"
    ],
    "answer": "Multiplies the key by itself and takes the middle digits"
  },
  {
    "id": 431,
    "topic": "General",
    "question": "5. Which of the following is an advantage of using the mid-square method for hashing?",
    "options": [
      "It provides a more uniform distribution of hash values.",
      "It is computationally less expensive than other methods.",
      "It guarantees no collisions for all input keys.",
      "It is easy to implement and requires little additional memory."
    ],
    "answer": "It provides a more uniform distribution of hash values."
  },
  {
    "id": 432,
    "topic": "General",
    "question": "6. Which of the following statements is true about the folding method?",
    "options": [
      "It is less prone to clustering compared to the division method.",
      "It is not affected by the size of the hash table.",
      "It requires the least amount of computation among all hash functions.",
      "It always guarantees a unique hash value for each input key."
    ],
    "answer": "It is less prone to clustering compared to the division method."
  },
  {
    "id": 433,
    "topic": "General",
    "question": "7. The folding method is particularly useful when:",
    "options": [
      "The hash table size is fixed.",
      "The keys are represented as floating-point numbers.",
      "The keys have fixed length and structure.",
      "The hash table uses linear probing for collision resolution."
    ],
    "answer": "The keys have fixed length and structure."
  },
  {
    "id": 434,
    "topic": "General",
    "question": "8. Which of the following statements is true about hash functions?",
    "options": [
      "A hash function that produces a unique hash value for each unique key is always a good hash function.",
      "The mid-square method is a deterministic hash function.",
      "All hash functions involve bitwise operations on the input key.",
      "Folding method can only be used with positive integer keys."
    ],
    "answer": "The mid-square method is a deterministic hash function."
  },
  {
    "id": 435,
    "topic": "General",
    "question": "**7.4 Collision Resolution** 1. Collision occurs in a hash table when:",
    "options": [
      "The hash function produces the same value for two different keys",
      "The hash table is full",
      "The hash table is empty",
      "The hash function is not deterministic"
    ],
    "answer": "The hash function produces the same value for two different keys"
  },
  {
    "id": 436,
    "topic": "General",
    "question": "2. Collision resolution techniques are used to:",
    "options": [
      "Increase the size of the hash table",
      "Avoid collisions",
      "Handle and resolve collisions",
      "Reduce the load factor of the hash table"
    ],
    "answer": "Handle and resolve collisions"
  },
  {
    "id": 437,
    "topic": "General",
    "question": "3. Which of the following is NOT a common collision resolution technique?",
    "options": [
      "Linear probing",
      "Quadratic probing",
      "Binary search",
      "Double hashing"
    ],
    "answer": "Binary search"
  },
  {
    "id": 438,
    "topic": "General",
    "question": "4. Collision resolution techniques aim to maintain the property of:",
    "options": [
      "Determinism",
      "Collisions",
      "Load factor",
      "Uniform distribution"
    ],
    "answer": "Uniform distribution"
  },
  {
    "id": 439,
    "topic": "General",
    "question": "5. Which of the following statements is true about collision resolution techniques?",
    "options": [
      "Linear probing always guarantees no collisions in a hash table.",
      "Quadratic probing is less prone to clustering than linear probing.",
      "Double hashing always requires a larger hash table size than other techniques.",
      "Separate chaining uses an additional data structure to store collided elements."
    ],
    "answer": "Separate chaining uses an additional data structure to store collided elements."
  },
  {
    "id": 440,
    "topic": "General",
    "question": "6. In the separate chaining collision resolution technique, each bucket in the hash table is a:",
    "options": [
      "Linked list",
      "Binary tree",
      "Fixed-size array",
      "Circular queue"
    ],
    "answer": "Linked list"
  },
  {
    "id": 441,
    "topic": "General",
    "question": "7. The main advantage of separate chaining is:",
    "options": [
      "Reduced memory usage",
      "Efficient space utilization",
      "Lower time complexity for insertion and search",
      "Higher load factor for the hash table"
    ],
    "answer": "Lower time complexity for insertion and search"
  },
  {
    "id": 442,
    "topic": "General",
    "question": "8. The performance of separate chaining depends on:",
    "options": [
      "The size of the hash table",
      "The type of hashing algorithm used",
      "The number of hash collisions",
      "The number of elements in the hash table"
    ],
    "answer": "The number of hash collisions"
  },
  {
    "id": 443,
    "topic": "General",
    "question": "**7.5 Linear Probing** 1. Linear probing is a collision resolution technique that:",
    "options": [
      "Uses a linked list to store collided elements",
      "Searches for an empty slot by incrementing the index linearly",
      "Searches for an empty slot by decrementing the index linearly",
      "Rehashes the key to resolve collisions"
    ],
    "answer": "Searches for an empty slot by incrementing the index linearly"
  },
  {
    "id": 444,
    "topic": "General",
    "question": "2. The main advantage of linear probing is:",
    "options": [
      "Efficient space utilization",
      "Low time complexity for search operations",
      "Low time complexity for insertion operations",
      "Uniform distribution of keys"
    ],
    "answer": "Low time complexity for search operations"
  },
  {
    "id": 445,
    "topic": "General",
    "question": "3. The primary drawback of linear probing is:",
    "options": [
      "Increased likelihood of clustering",
      "High time complexity for search operations",
      "High time complexity for insertion operations",
      "Decreased load factor"
    ],
    "answer": "Increased likelihood of clustering"
  },
  {
    "id": 446,
    "topic": "General",
    "question": "4. Linear probing may cause performance degradation when the load factor of the hash table:",
    "options": [
      "Is close to 0.5",
      "Is close to 1",
      "Is greater than 1",
      "Is less than 1"
    ],
    "answer": "Is close to 1"
  },
  {
    "id": 447,
    "topic": "General",
    "question": "5. Linear probing can lead to a phenomenon called \"primary clustering.\" What does primary clustering refer to in linear probing?",
    "options": [
      "Keys that hash to the same index form a chain",
      "Collided elements are placed at the beginning of the table",
      "Collided elements are evenly distributed across the table",
      "The hash table is resized to accommodate more elements"
    ],
    "answer": "Keys that hash to the same index form a chain"
  },
  {
    "id": 448,
    "topic": "General",
    "question": "6. Which of the following statements is true about linear probing?",
    "options": [
      "It guarantees no collisions in the hash table.",
      "It is faster than quadratic probing for searching.",
      "It always requires more space than separate chaining.",
      "It is not affected by the initial size of the hash table."
    ],
    "answer": "It is faster than quadratic probing for searching."
  },
  {
    "id": 449,
    "topic": "General",
    "question": "7. The efficiency of linear probing is highly dependent on:",
    "options": [
      "The hash function used",
      "The number of elements in the hash table",
      "The size of the hash table",
      "The number of collisions in the hash table"
    ],
    "answer": "The size of the hash table"
  },
  {
    "id": 450,
    "topic": "General",
    "question": "8. The linear probing technique usually requires __________ additional memory compared to separate chaining.",
    "options": [
      "More",
      "Less",
      "The same amount of",
      "No"
    ],
    "answer": "Less"
  },
  {
    "id": 451,
    "topic": "General",
    "question": "**7.6 Quadratic Probing** 1. Quadratic probing is a collision resolution technique that:",
    "options": [
      "Uses a linked list to store collided elements",
      "Searches for an empty slot by incrementing the index quadratically",
      "Searches for an empty slot by decrementing the index quadratically",
      "Rehashes the key to resolve collisions"
    ],
    "answer": "Searches for an empty slot by incrementing the index quadratically"
  },
  {
    "id": 452,
    "topic": "General",
    "question": "2. The main advantage of quadratic probing is:",
    "options": [
      "Efficient space utilization",
      "Low time complexity for search operations",
      "Low time complexity for insertion operations",
      "Uniform distribution of keys"
    ],
    "answer": "Efficient space utilization"
  },
  {
    "id": 453,
    "topic": "General",
    "question": "3. The primary drawback of quadratic probing is:",
    "options": [
      "Increased likelihood of clustering",
      "High time complexity for search operations",
      "High time complexity for insertion operations",
      "Decreased load factor"
    ],
    "answer": "Increased likelihood of clustering"
  },
  {
    "id": 454,
    "topic": "General",
    "question": "4. Quadratic probing may cause performance degradation when the load factor of the hash table:",
    "options": [
      "Is close to 0.5",
      "Is close to 1",
      "Is greater than 1",
      "Is less than 1"
    ],
    "answer": "Is close to 1"
  },
  {
    "id": 455,
    "topic": "General",
    "question": "5. Quadratic probing can mitigate the problem of primary clustering experienced in linear probing. How does quadratic probing achieve this?",
    "options": [
      "By rehashing the keys that cause primary clustering",
      "By evenly distributing collided elements across the table",
      "By incrementing the index quadratically to find empty slots",
      "By using a different hash function for quadratic probing"
    ],
    "answer": "By incrementing the index quadratically to find empty slots"
  },
  {
    "id": 456,
    "topic": "General",
    "question": "6. Which of the following statements is true about quadratic probing?",
    "options": [
      "It guarantees no collisions in the hash table.",
      "It is faster than linear probing for searching.",
      "It requires more memory than separate chaining.",
      "It does not suffer from secondary clustering."
    ],
    "answer": "It does not suffer from secondary clustering."
  },
  {
    "id": 457,
    "topic": "General",
    "question": "7. The efficiency of quadratic probing depends on:",
    "options": [
      "The initial size of the hash table",
      "The number of elements in the hash table",
      "The type of keys being hashed",
      "The load factor of the hash table"
    ],
    "answer": "The number of elements in the hash table"
  },
  {
    "id": 458,
    "topic": "General",
    "question": "8. Quadratic probing can handle more collisions compared to linear probing before causing primary clustering. What is the primary advantage of this property?",
    "options": [
      "It allows for faster search operations.",
      "It requires less memory for the hash table.",
      "It reduces the need for hash table resizing.",
      "It guarantees a lower load factor."
    ],
    "answer": "It reduces the need for hash table resizing."
  },
  {
    "id": 459,
    "topic": "General",
    "question": "**7.7 Double Hashing** 1. Double hashing is a collision resolution technique that:",
    "options": [
      "Uses a linked list to store collided elements",
      "Uses two different hash functions to find an empty slot",
      "Uses the same hash function for the first and second probes",
      "Rehashes the key to resolve collisions"
    ],
    "answer": "Uses two different hash functions to find an empty slot"
  },
  {
    "id": 460,
    "topic": "General",
    "question": "2. In double hashing, the second hash function is used to calculate:",
    "options": [
      "The offset for the primary cluster",
      "The step size for the linear probe",
      "The index to probe for an empty slot",
      "The initial hash value for the key"
    ],
    "answer": "The index to probe for an empty slot"
  },
  {
    "id": 461,
    "topic": "General",
    "question": "3. The main advantage of double hashing is:",
    "options": [
      "Efficient space utilization",
      "Low time complexity for search operations",
      "Low time complexity for insertion operations",
      "Uniform distribution of keys"
    ],
    "answer": "Uniform distribution of keys"
  },
  {
    "id": 462,
    "topic": "General",
    "question": "4. Double hashing may cause performance degradation when the load factor of the hash table:",
    "options": [
      "Is close to 0.5",
      "Is close to 1",
      "Is greater than 1",
      "Is less than 1"
    ],
    "answer": "Is close to 1"
  },
  {
    "id": 463,
    "topic": "General",
    "question": "5. Double hashing can handle primary clustering that occurs in linear probing. How does double hashing achieve this?",
    "options": [
      "By using two different hash functions to distribute collided elements",
      "By rehashing the keys that cause primary clustering",
      "By using a quadratic step size for the linear probe",
      "By creating a separate linked list for collided elements"
    ],
    "answer": "By using two different hash functions to distribute collided elements"
  },
  {
    "id": 464,
    "topic": "General",
    "question": "6. Which of the following statements is true about double hashing?",
    "options": [
      "It guarantees no collisions in the hash table.",
      "It is faster than linear probing for searching.",
      "It requires more memory than separate chaining.",
      "It is immune to primary clustering."
    ],
    "answer": "It is immune to primary clustering."
  },
  {
    "id": 465,
    "topic": "General",
    "question": "7. The performance of double hashing is dependent on:",
    "options": [
      "The size of the hash table",
      "The number of elements in the hash table",
      "The type of keys being hashed",
      "The load factor of the hash table"
    ],
    "answer": "The size of the hash table"
  },
  {
    "id": 466,
    "topic": "General",
    "question": "8. Which of the following is an advantage of using double hashing over linear probing?",
    "options": [
      "Lower likelihood of collisions",
      "Faster search operations",
      "Reduced primary clustering",
      "Better space utilization"
    ],
    "answer": "Reduced primary clustering"
  },
  {
    "id": 467,
    "topic": "General",
    "question": "**7.8 Inserting and Deleting an Element from a Hash Table** 1. When inserting a new element into a hash table using separate chaining, where should the element be placed?",
    "options": [
      "At the first available slot in the hash table",
      "At the beginning of the linked list in the corresponding bucket",
      "At the end of the linked list in the corresponding bucket",
      "At the position determined by the second hash function"
    ],
    "answer": "At the end of the linked list in the corresponding bucket"
  },
  {
    "id": 468,
    "topic": "General",
    "question": "2. In separate chaining, if the load factor of the hash table is high, what can be done to avoid hash table overflow?",
    "options": [
      "Resize the hash table to increase its size",
      "Use linear probing for collision resolution",
      "Use quadratic probing for collision resolution",
      "Use a different hash function"
    ],
    "answer": "Resize the hash table to increase its size"
  },
  {
    "id": 469,
    "topic": "General",
    "question": "3. When deleting an element from a hash table using separate chaining, what should be done with the linked list in the corresponding bucket?",
    "options": [
      "Delete the linked list",
      "Remove the element from the linked list",
      "Rehash the linked list",
      "Reverse the linked list"
    ],
    "answer": "Remove the element from the linked list"
  },
  {
    "id": 470,
    "topic": "General",
    "question": "4. In double hashing, how is the step size for the linear probe determined?",
    "options": [
      "By the first hash function",
      "By the second hash function",
      "By the difference between the hash values generated by the two hash functions",
      "By the load factor of the hash table"
    ],
    "answer": "By the second hash function"
  },
  {
    "id": 471,
    "topic": "General",
    "question": "5. Which collision resolution technique has the least likelihood of causing secondary clustering?",
    "options": [
      "Linear probing",
      "Quadratic probing",
      "Double hashing",
      "Separate chaining"
    ],
    "answer": "Double hashing"
  },
  {
    "id": 472,
    "topic": "General",
    "question": "6. When using quadratic probing for collision resolution, what happens if the computed index for the next probe exceeds the size of the hash table?",
    "options": [
      "The probe continues from the beginning of the hash table.",
      "The probe continues from the last available slot in the hash table.",
      "The probe wraps around to the initial position and starts again.",
      "The element is placed in the next available slot in the hash table."
    ],
    "answer": "The probe wraps around to the initial position and starts again."
  },
  {
    "id": 473,
    "topic": "General",
    "question": "7. In double hashing, what is the primary purpose of using two different hash functions?",
    "options": [
      "To reduce the number of collisions",
      "To ensure uniform distribution of keys",
      "To avoid hash table overflow",
      "To improve search efficiency"
    ],
    "answer": "To reduce the number of collisions"
  },
  {
    "id": 474,
    "topic": "General",
    "question": "8. Which of the following is a common approach to handle hash table overflow when using separate chaining?",
    "options": [
      "Rehashing the entire hash table",
      "Increasing the size of the hash table",
      "Using a different hash function",
      "Implementing linear probing"
    ],
    "answer": "Increasing the size of the hash table"
  },
  {
    "id": 475,
    "topic": "General",
    "question": "Lecture 8: Graphs & Applications **8.1 Introduction to graph theory** 1. Graph theory is the study of:",
    "options": [
      "Mathematical functions and equations",
      "Relationships between objects and their connections",
      "Data analysis and visualization techniques",
      "Artificial intelligence and machine learning"
    ],
    "answer": "Relationships between objects and their connections"
  },
  {
    "id": 476,
    "topic": "General",
    "question": "2. A graph in graph theory consists of:",
    "options": [
      "Vertices and edges",
      "Equations and variables",
      "Rows and columns",
      "Points and lines"
    ],
    "answer": "Vertices and edges"
  },
  {
    "id": 477,
    "topic": "General",
    "question": "3. In a graph, vertices represent:",
    "options": [
      "The paths between edges",
      "The connections or entities",
      "The mathematical functions",
      "The axis labels"
    ],
    "answer": "The connections or entities"
  },
  {
    "id": 478,
    "topic": "General",
    "question": "4. What is the purpose of using graph theory?",
    "options": [
      "To solve numerical equations",
      "To analyze large datasets",
      "To visualize complex relationships",
      "To perform statistical analysis"
    ],
    "answer": "To visualize complex relationships"
  },
  {
    "id": 479,
    "topic": "General",
    "question": "5. Which of the following is NOT a real-world application of graph theory?",
    "options": [
      "Social network analysis",
      "Route planning and optimization",
      "Image and speech recognition",
      "Computer networks and communication"
    ],
    "answer": "Image and speech recognition"
  },
  {
    "id": 480,
    "topic": "General",
    "question": "**8.2 Graph Terminology** 6. The degree of a vertex in a graph is:",
    "options": [
      "The number of edges connected to that vertex",
      "The sum of all the vertex values in the graph",
      "The total number of vertices in the graph",
      "The number of connected components in the graph"
    ],
    "answer": "The number of edges connected to that vertex"
  },
  {
    "id": 481,
    "topic": "General",
    "question": "7. A graph is called \"undirected\" when:",
    "options": [
      "It has no cycles",
      "It has multiple connected components",
      "The edges have direction or arrows",
      "The edges have no direction or arrows"
    ],
    "answer": "The edges have no direction or arrows"
  },
  {
    "id": 482,
    "topic": "General",
    "question": "8. What does a \"cycle\" in a graph mean?",
    "options": [
      "A set of vertices without any edges",
      "A path that starts and ends at the same vertex",
      "A collection of disconnected components",
      "A set of edges without any vertices"
    ],
    "answer": "A path that starts and ends at the same vertex"
  },
  {
    "id": 483,
    "topic": "General",
    "question": "9. A graph with all its vertices connected and no cycles is called:",
    "options": [
      "Disconnected graph",
      "Directed graph",
      "Tree",
      "Complete graph"
    ],
    "answer": "Tree"
  },
  {
    "id": 484,
    "topic": "General",
    "question": "10. A \"subgraph\" of a graph is:",
    "options": [
      "A graph with fewer vertices than the original graph",
      "A graph with additional vertices and edges",
      "A graph with the same vertices but different edges",
      "A graph with all its vertices having the same degree"
    ],
    "answer": "A graph with fewer vertices than the original graph"
  },
  {
    "id": 485,
    "topic": "General",
    "question": "**8.3 Different types of Graphs** 11. A graph is called \"connected\" when:",
    "options": [
      "It has a cycle",
      "It has no cycles",
      "It has only one vertex",
      "There is a path between every pair of vertices"
    ],
    "answer": "There is a path between every pair of vertices"
  },
  {
    "id": 486,
    "topic": "General",
    "question": "12. A \"directed graph\" is a graph where:",
    "options": [
      "All edges have the same weight",
      "All edges have direction or arrows",
      "All vertices have the same degree",
      "The graph has no cycles"
    ],
    "answer": "All edges have direction or arrows"
  },
  {
    "id": 487,
    "topic": "General",
    "question": "13. In a \"weighted graph,\" the edges:",
    "options": [
      "Have no direction",
      "Have no weight or value",
      "Have direction but no weight",
      "Have numerical values or weights"
    ],
    "answer": "Have numerical values or weights"
  },
  {
    "id": 488,
    "topic": "General",
    "question": "14. A \"complete graph\" is a graph where:",
    "options": [
      "All vertices have the same degree",
      "There is an edge between every pair of vertices",
      "There are no cycles",
      "All edges have the same weight"
    ],
    "answer": "There is an edge between every pair of vertices"
  },
  {
    "id": 489,
    "topic": "General",
    "question": "15. A graph with two or more disconnected components is called:",
    "options": [
      "Bipartite graph",
      "Connected graph",
      "Disconnected graph",
      "Cyclic graph"
    ],
    "answer": "Disconnected graph"
  },
  {
    "id": 490,
    "topic": "General",
    "question": "**8.4 Representation of Graphs** **8.4.1 Adjacency Matrix** 16. In an adjacency matrix representation, the value at matrix[i][j] indicates:",
    "options": [
      "The weight of the edge between vertex i and vertex j",
      "The number of edges between vertex i and vertex j",
      "The presence of an edge between vertex i and vertex j",
      "The number of neighbors of vertex i"
    ],
    "answer": "The presence of an edge between vertex i and vertex j"
  },
  {
    "id": 491,
    "topic": "General",
    "question": "17. The space complexity of an adjacency matrix for an undirected graph with n vertices is:",
    "options": [
      "O(n)",
      "O(n^2)",
      "O(n log n)",
      "O(1)"
    ],
    "answer": "O(n^2)"
  },
  {
    "id": 492,
    "topic": "General",
    "question": "18. Which statement is true about an adjacency matrix?",
    "options": [
      "It is more memory-efficient for sparse graphs",
      "It is suitable for graphs with variable-sized vertices",
      "It requires less time for graph traversal",
      "It is less efficient for adding or removing edges"
    ],
    "answer": "It is less efficient for adding or removing edges"
  },
  {
    "id": 493,
    "topic": "General",
    "question": "19. An adjacency matrix representation is ideal for:",
    "options": [
      "Unweighted graphs",
      "Directed graphs with cycles",
      "Graphs with large numbers of disconnected components",
      "Graphs with a small number of edges"
    ],
    "answer": "Graphs with large numbers of disconnected components"
  },
  {
    "id": 494,
    "topic": "General",
    "question": "20. An adjacency matrix for an undirected graph is:",
    "options": [
      "Always symmetric with respect to the main diagonal",
      "Symmetric if the graph has no cycles",
      "Symmetric if the graph has no isolated vertices",
      "Symmetric if all edges have the same weight"
    ],
    "answer": "Always symmetric with respect to the main diagonal"
  },
  {
    "id": 495,
    "topic": "General",
    "question": "**8.4.2 Adjacency List** 21. In an adjacency list representation, each vertex maintains:",
    "options": [
      "A list of its neighbors",
      "A list of its adjacent edges",
      "A list of its parent and child vertices",
      "A list of its degrees and connections"
    ],
    "answer": "A list of its neighbors"
  },
  {
    "id": 496,
    "topic": "General",
    "question": "22. The space complexity of an adjacency list for a graph with n vertices and e edges is:",
    "options": [
      "O(n)",
      "O(e)",
      "O(n + e)",
      "O(n * e)"
    ],
    "answer": "O(n + e)"
  },
  {
    "id": 497,
    "topic": "General",
    "question": "23. Which statement is true about an adjacency list?",
    "options": [
      "It is more memory-efficient for dense graphs",
      "It is suitable for graphs with a large number of isolated vertices",
      "It requires more time for graph traversal compared to an adjacency matrix",
      "It is less efficient for finding the degree of a vertex"
    ],
    "answer": "It is more memory-efficient for dense graphs"
  },
  {
    "id": 498,
    "topic": "General",
    "question": "24. An adjacency list representation is ideal for:",
    "options": [
      "Graphs with a small number of edges",
      "Directed graphs with cycles",
      "Graphs with a large number of isolated vertices",
      "Unweighted graphs"
    ],
    "answer": "Graphs with a small number of edges"
  },
  {
    "id": 499,
    "topic": "General",
    "question": "25. In an adjacency list representation, the time complexity to check if there is an edge between two vertices is:",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(e)"
    ],
    "answer": "O(1)"
  },
  {
    "id": 500,
    "topic": "General",
    "question": "**8.4.3 Graph Traversal Algorithms (Breadth First Search, Depth First Search)** 26. Breadth First Search (BFS) explores the graph in which order?",
    "options": [
      "From the deepest nodes to the root",
      "From the first encountered vertex to the last",
      "From the source vertex to the farthest vertices",
      "From the last encountered vertex to the first"
    ],
    "answer": "From the source vertex to the farthest vertices"
  },
  {
    "id": 501,
    "topic": "General",
    "question": "27. Depth First Search (DFS) uses a:",
    "options": [
      "Queue data structure",
      "Stack data structure",
      "Priority queue data structure",
      "Heap data structure"
    ],
    "answer": "Stack data structure"
  },
  {
    "id": 502,
    "topic": "General",
    "question": "28. In BFS, the shortest path between two vertices in an unweighted graph is found by:",
    "options": [
      "Maintaining a priority queue of vertices",
      "Exploring all possible paths from the source to the destination",
      "Exploring the graph level by level",
      "Using Dijkstra's algorithm"
    ],
    "answer": "Exploring the graph level by level"
  },
  {
    "id": 503,
    "topic": "General",
    "question": "29. DFS is used to:",
    "options": [
      "Find the shortest path in a graph",
      "Find the longest path in a graph",
      "Explore all possible paths in a graph",
      "Only traverse connected components of the graph"
    ],
    "answer": "Explore all possible paths in a graph"
  },
  {
    "id": 504,
    "topic": "General",
    "question": "30. Which traversal algorithm is more suitable for finding the shortest path in an unweighted graph?",
    "options": [
      "BFS (Breadth First Search)",
      "DFS (Depth First Search)",
      "Both BFS and DFS are equally suitable",
      "Neither BFS nor DFS can find the shortest path"
    ],
    "answer": "BFS (Breadth First Search)"
  },
  {
    "id": 505,
    "topic": "General",
    "question": "**8.5 Shortest Path** **8.5.1 Level Setting: Dijkstra's algorithm** 31. Dijkstra's algorithm is used to find the shortest path in:",
    "options": [
      "Unweighted graphs",
      "Directed graphs only",
      "Connected graphs with no cycles",
      "Graphs with non-negative edge weights"
    ],
    "answer": "Graphs with non-negative edge weights"
  },
  {
    "id": 506,
    "topic": "General",
    "question": "32. The priority queue is a crucial data structure used in Dijkstra's algorithm to:",
    "options": [
      "Store all the vertices of the graph",
      "Keep track of visited vertices",
      "Maintain the distances to each vertex from the source",
      "Ensure that the graph has no cycles"
    ],
    "answer": "Maintain the distances to each vertex from the source"
  },
  {
    "id": 507,
    "topic": "General",
    "question": "33. In Dijkstra's algorithm, what happens when a shorter path to a vertex is discovered?",
    "options": [
      "The vertex is marked as visited and added to the shortest path tree",
      "The vertex is removed from the priority queue",
      "The distance to the vertex is updated in the priority queue",
      "The algorithm backtracks to the previous vertex"
    ],
    "answer": "The distance to the vertex is updated in the priority queue"
  },
  {
    "id": 508,
    "topic": "General",
    "question": "34. Which statement is true about Dijkstra's algorithm?",
    "options": [
      "It is a greedy algorithm that selects the vertex with the maximum distance at each step.",
      "It is guaranteed to find the shortest path in graphs with negative edge weights.",
      "It can handle graphs with cycles.",
      "It requires the graph to be connected."
    ],
    "answer": "It can handle graphs with cycles."
  },
  {
    "id": 509,
    "topic": "General",
    "question": "35. Dijkstra's algorithm may not work correctly on graphs with:",
    "options": [
      "Non-negative edge weights",
      "Cycles",
      "Sparse vertices",
      "Unconnected components"
    ],
    "answer": "Cycles"
  },
  {
    "id": 510,
    "topic": "General",
    "question": "**8.5.2 Level Correcting: All-pairs shortest path, Floyd-Warshall algorithm** 36. Floyd-Warshall algorithm is used to find:",
    "options": [
      "The shortest path between all pairs of vertices in a weighted graph",
      "The shortest path between two specified vertices in an unweighted graph",
      "The longest path in a directed graph",
      "The shortest cycle in a graph"
    ],
    "answer": "The shortest path between all pairs of vertices in a weighted graph"
  },
  {
    "id": 511,
    "topic": "General",
    "question": "37. The Floyd-Warshall algorithm works for graphs with:",
    "options": [
      "Non-negative edge weights only",
      "Negative edge weights only",
      "Non-negative and negative edge weights",
      "Non-negative edge weights and cycles only"
    ],
    "answer": "Non-negative and negative edge weights"
  },
  {
    "id": 512,
    "topic": "General",
    "question": "38. The time complexity of the Floyd-Warshall algorithm for a graph with V vertices is:",
    "options": [
      "O(V)",
      "O(V^2)",
      "O(V^3)",
      "O(log V)"
    ],
    "answer": "O(V^3)"
  },
  {
    "id": 513,
    "topic": "General",
    "question": "39. The Floyd-Warshall algorithm uses a dynamic programming approach to find the shortest path. What does \"dynamic programming\" mean in this context?",
    "options": [
      "Solving a problem by breaking it into smaller subproblems and storing their solutions",
      "Using random values to update the distance matrix",
      "Always selecting the shortest path at each step",
      "Simulating all possible paths in the graph"
    ],
    "answer": "Solving a problem by breaking it into smaller subproblems and storing their solutions"
  },
  {
    "id": 514,
    "topic": "General",
    "question": "40. The Floyd-Warshall algorithm can handle graphs with:",
    "options": [
      "Negative cycles",
      "Disconnected components",
      "Only a single vertex",
      "Vertices with no edges"
    ],
    "answer": "Negative cycles"
  },
  {
    "id": 515,
    "topic": "General",
    "question": "**8.6 Spanning Trees** **8.6.1 Minimum spanning tree algorithms** 41. A minimum spanning tree (MST) of a graph is:",
    "options": [
      "The tree with the smallest number of edges",
      "The tree with the smallest total edge weight",
      "The tree with the smallest number of vertices",
      "The tree with the smallest maximum degree of vertices"
    ],
    "answer": "The tree with the smallest total edge weight"
  },
  {
    "id": 516,
    "topic": "General",
    "question": "42. Prim's algorithm is used to find the:",
    "options": [
      "Shortest path in a graph",
      "Longest path in a graph",
      "Minimum spanning tree of a graph",
      "Maximum spanning tree of a graph"
    ],
    "answer": "Minimum spanning tree of a graph"
  },
  {
    "id": 517,
    "topic": "General",
    "question": "43. The time complexity of Prim's algorithm for finding the minimum spanning tree in a graph with V vertices is:",
    "options": [
      "O(V)",
      "O(V^2)",
      "O(V^3)",
      "O(V log V)"
    ],
    "answer": "O(V^2)"
  },
  {
    "id": 518,
    "topic": "General",
    "question": "44. Prim's algorithm starts with:",
    "options": [
      "The first vertex of the graph",
      "The vertex with the maximum degree",
      "The vertex with the minimum degree",
      "Any arbitrary vertex of the graph"
    ],
    "answer": "Any arbitrary vertex of the graph"
  },
  {
    "id": 519,
    "topic": "General",
    "question": "45. In Prim's algorithm, what happens when two disconnected components are present in the graph?",
    "options": [
      "The algorithm enters an infinite loop",
      "The algorithm outputs an error message",
      "The algorithm connects the components with a minimum weight edge",
      "The algorithm cannot handle disconnected components"
    ],
    "answer": "The algorithm connects the components with a minimum weight edge"
  },
  {
    "id": 520,
    "topic": "General",
    "question": "**8.6.2 Prim's Algorithm** 46. When using Prim's algorithm, the initial vertex for the minimum spanning tree is chosen:",
    "options": [
      "Arbitrarily",
      "As the vertex with the smallest degree",
      "As the vertex with the largest degree",
      "As the vertex with the smallest total edge weight"
    ],
    "answer": "Arbitrarily"
  },
  {
    "id": 521,
    "topic": "General",
    "question": "47. Prim's algorithm grows the minimum spanning tree by adding:",
    "options": [
      "The edge with the smallest weight from the current tree to a new vertex",
      "The edge with the largest weight from the current tree to a new vertex",
      "The edge with the smallest weight among all edges",
      "The edge with the largest weight among all edges"
    ],
    "answer": "The edge with the smallest weight from the current tree to a new vertex"
  },
  {
    "id": 522,
    "topic": "General",
    "question": "48. Which statement is true about Prim's algorithm for finding the minimum spanning tree?",
    "options": [
      "It can handle graphs with negative edge weights",
      "It always starts with the vertex having the smallest degree",
      "It may not work correctly for disconnected graphs",
      "It guarantees the maximum spanning tree of the graph"
    ],
    "answer": "It may not work correctly for disconnected graphs"
  },
  {
    "id": 523,
    "topic": "General",
    "question": "49. Prim's algorithm terminates when:",
    "options": [
      "All vertices are added to the minimum spanning tree",
      "The maximum weight edge is added to the tree",
      "There is no vertex left in the graph",
      "There are no more edges left in the graph"
    ],
    "answer": "All vertices are added to the minimum spanning tree"
  },
  {
    "id": 524,
    "topic": "General",
    "question": "50. The minimum spanning tree found by Prim's algorithm is unique if:",
    "options": [
      "Shortest path in a graph",
      "Longest path in a graph",
      "Maximum spanning tree of a graph",
      "Minimum spanning tree of a graph"
    ],
    "answer": "Minimum spanning tree of a graph"
  },
  {
    "id": 525,
    "topic": "General",
    "question": "52. Kruskal's algorithm sorts the edges of the graph based on:",
    "options": [
      "The vertices they connect",
      "The edge weights in non-decreasing order",
      "The edge weights in non-increasing order",
      "The total number of edges"
    ],
    "answer": "The edge weights in non-decreasing order"
  },
  {
    "id": 526,
    "topic": "General",
    "question": "53. The time complexity of Kruskal's algorithm for finding the minimum spanning tree in a graph with E edges and V vertices is:",
    "options": [
      "O(E)",
      "O(E log V)",
      "O(V^2)",
      "O(V log V)"
    ],
    "answer": "O(E log V)"
  },
  {
    "id": 527,
    "topic": "General",
    "question": "54. Kruskal's algorithm starts with:",
    "options": [
      "The first vertex of the graph",
      "The smallest edge of the graph",
      "The largest edge of the graph",
      "Any arbitrary vertex of the graph"
    ],
    "answer": "The smallest edge of the graph"
  },
  {
    "id": 528,
    "topic": "General",
    "question": "55. In Kruskal's algorithm, what happens when two disconnected components are present in the graph?",
    "options": [
      "The algorithm enters an infinite loop",
      "The algorithm outputs an error message",
      "The algorithm connects the components with a minimum weight edge",
      "The algorithm cannot handle disconnected components"
    ],
    "answer": "The algorithm connects the components with a minimum weight edge"
  },
  {
    "id": 529,
    "topic": "General",
    "question": "Lecture 9: Algorithm Designs **9.1 What are the different classes of algorithms** 56. Which class of algorithms is used to find the shortest path in a graph with non-negative edge weights?",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Dynamic Programming algorithm",
      "Shortest Path algorithm"
    ],
    "answer": "Shortest Path algorithm"
  },
  {
    "id": 530,
    "topic": "General",
    "question": "57. The class of algorithms that breaks a problem into smaller subproblems and solves each subproblem independently is called:",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Dynamic Programming algorithm",
      "Brute force algorithm"
    ],
    "answer": "Divide and Conquer algorithm"
  },
  {
    "id": 531,
    "topic": "General",
    "question": "58. The \"Greedy algorithm\" always makes the locally optimal choice at each step, with the hope of finding a global optimum. Which statement is true about Greedy algorithms?",
    "options": [
      "Greedy algorithms always guarantee the global optimum for all problems.",
      "Greedy algorithms are usually more time-efficient than other algorithm classes.",
      "Greedy algorithms can sometimes lead to suboptimal solutions for some problems.",
      "Greedy algorithms are only applicable to problems with a small number of variables."
    ],
    "answer": "Greedy algorithms can sometimes lead to suboptimal solutions for some problems."
  },
  {
    "id": 532,
    "topic": "General",
    "question": "59. Dynamic Programming algorithms are particularly useful for solving problems that exhibit:",
    "options": [
      "Overlapping subproblems and optimal substructure",
      "Low complexity and small input size",
      "Independent subproblems and no overlapping",
      "Linear data structures and one-dimensional arrays"
    ],
    "answer": "Overlapping subproblems and optimal substructure"
  },
  {
    "id": 533,
    "topic": "General",
    "question": "60. Brute force algorithms:",
    "options": [
      "Always guarantee the optimal solution",
      "Are the most efficient for large-scale problems",
      "Examine all possible solutions and select the best one",
      "Are suitable only for problems with a small number of variables"
    ],
    "answer": "Examine all possible solutions and select the best one"
  },
  {
    "id": 534,
    "topic": "General",
    "question": "**9.2 How to write efficient Algorithm** 61. Writing an efficient algorithm involves:",
    "options": [
      "Solving the problem in the shortest amount of time",
      "Minimizing the number of steps in the algorithm",
      "Optimizing the use of memory and computational resources",
      "Reducing the input size of the problem"
    ],
    "answer": "Optimizing the use of memory and computational resources"
  },
  {
    "id": 535,
    "topic": "General",
    "question": "62. An algorithm that has a time complexity of O(log n) is considered more efficient than an algorithm with time complexity:",
    "options": [
      "O(1)",
      "O(n)",
      "O(n^2)",
      "O(n log n)"
    ],
    "answer": "O(n log n)"
  },
  {
    "id": 536,
    "topic": "General",
    "question": "63. Which strategy is NOT typically used to improve the efficiency of an algorithm?",
    "options": [
      "Divide and Conquer",
      "Brute force",
      "Dynamic Programming",
      "Memoization"
    ],
    "answer": "Brute force"
  },
  {
    "id": 537,
    "topic": "General",
    "question": "64. The concept of \"memoization\" in algorithm design refers to:",
    "options": [
      "Optimizing the algorithm for memory usage",
      "Caching and reusing intermediate results to avoid redundant computations",
      "Applying the greedy strategy to all possible solutions",
      "Using only the most basic data structures"
    ],
    "answer": "Caching and reusing intermediate results to avoid redundant computations"
  },
  {
    "id": 538,
    "topic": "General",
    "question": "65. Which statement is true about the efficiency of an algorithm?",
    "options": [
      "An efficient algorithm always has the smallest code size.",
      "An efficient algorithm always guarantees the optimal solution.",
      "The efficiency of an algorithm is solely determined by the programming language used.",
      "The efficiency of an algorithm can be measured by its time and space complexity."
    ],
    "answer": "The efficiency of an algorithm can be measured by its time and space complexity."
  },
  {
    "id": 539,
    "topic": "General",
    "question": "**9.3 Introduction to algorithm design techniques** 66. The primary goal of algorithm design techniques is to:",
    "options": [
      "Write algorithms with the least number of steps",
      "Create algorithms that always yield the correct result",
      "Develop efficient algorithms to solve specific problems",
      "Minimize the use of data structures in the algorithm"
    ],
    "answer": "Develop efficient algorithms to solve specific problems"
  },
  {
    "id": 540,
    "topic": "General",
    "question": "67. Algorithm design techniques help in:",
    "options": [
      "Generating random solutions to problems",
      "Transforming complex problems into simple ones",
      "Maximizing the number of steps in an algorithm",
      "Avoiding the use of mathematical concepts in algorithms"
    ],
    "answer": "Transforming complex problems into simple ones"
  },
  {
    "id": 541,
    "topic": "General",
    "question": "68. Which of the following algorithm design techniques emphasizes breaking a problem into smaller subproblems and solving each subproblem independently?",
    "options": [
      "Greedy algorithm",
      "Divide and Conquer algorithm",
      "Brute force algorithm",
      "Dynamic Programming algorithm"
    ],
    "answer": "Divide and Conquer algorithm"
  },
  {
    "id": 542,
    "topic": "General",
    "question": "69. Algorithm design techniques involve the use of:",
    "options": [
      "Randomized approaches to problem-solving",
      "Only a single approach for all types of problems",
      "Domain-specific heuristics for problem-solving",
      "A combination of methods and strategies tailored to the problem"
    ],
    "answer": "A combination of methods and strategies tailored to the problem"
  },
  {
    "id": 543,
    "topic": "General",
    "question": "70. The main purpose of using algorithm design techniques is to:",
    "options": [
      "Increase the difficulty of the algorithm",
      "Implement the most complex algorithms for a problem",
      "Improve the code readability and maintainability",
      "Optimize the algorithm's efficiency for a specific problem"
    ],
    "answer": "Optimize the algorithm's efficiency for a specific problem"
  },
  {
    "id": 544,
    "topic": "General",
    "question": "**9.4 Algorithm Design techniques** 71. The \"Greedy algorithm\" always makes the locally optimal choice at each step, with the hope of finding a global optimum. Which statement is true about Greedy algorithms?",
    "options": [
      "Greedy algorithms always guarantee the global optimum for all problems.",
      "Greedy algorithms are usually more time-efficient than other algorithm classes.",
      "Greedy algorithms can sometimes lead to suboptimal solutions for some problems.",
      "Greedy algorithms are only applicable to problems with a small number of variables."
    ],
    "answer": "Greedy algorithms can sometimes lead to suboptimal solutions for some problems."
  },
  {
    "id": 545,
    "topic": "General",
    "question": "72. Dynamic Programming algorithms are particularly useful for solving problems that exhibit:",
    "options": [
      "Overlapping subproblems and optimal substructure",
      "Low complexity and small input size c ) Independent subproblems and no overlapping",
      "Linear data structures and one-dimensional arrays"
    ],
    "answer": "Overlapping subproblems and optimal substructure"
  },
  {
    "id": 546,
    "topic": "General",
    "question": "73. Brute force algorithms:",
    "options": [
      "Always guarantee the optimal solution",
      "Are the most efficient for large-scale problems",
      "Examine all possible solutions and select the best one",
      "Are suitable only for problems with a small number of variables"
    ],
    "answer": "Examine all possible solutions and select the best one"
  },
  {
    "id": 547,
    "topic": "General",
    "question": "74. Divide and Conquer algorithms break a problem into:",
    "options": [
      "Random subproblems",
      "Smaller subproblems of equal size",
      "Independent subproblems",
      "Overlapping subproblems"
    ],
    "answer": "Smaller subproblems of equal size"
  },
  {
    "id": 548,
    "topic": "General",
    "question": "75. Backtracking algorithms are used to solve problems that involve:",
    "options": [
      "Finding the shortest path in a graph",
      "Searching for an element in a sorted array",
      "Exploring all possible solutions and making choices along the way",
      "Dividing the problem into two smaller subproblems"
    ],
    "answer": "Exploring all possible solutions and making choices along the way"
  },
  {
    "id": 549,
    "topic": "General",
    "question": "**9.5 Analysis of an Algorithm** **9.5.1 Asymptotic Analysis** 76. Asymptotic analysis of an algorithm evaluates its performance as:",
    "options": [
      "The input size approaches infinity",
      "The input size remains constant",
      "The algorithm runs on random inputs",
      "The algorithm handles edge cases"
    ],
    "answer": "The input size approaches infinity"
  },
  {
    "id": 550,
    "topic": "General",
    "question": "77. In asymptotic analysis, the term \"Big O notation\" is used to represent the:",
    "options": [
      "Best-case time complexity of the algorithm",
      "Average-case time complexity of the algorithm",
      "Worst-case time complexity of the algorithm",
      "Space complexity of the algorithm"
    ],
    "answer": "Worst-case time complexity of the algorithm"
  },
  {
    "id": 551,
    "topic": "General",
    "question": "78. The Big O notation O(n) represents an algorithm with:",
    "options": [
      "Constant time complexity",
      "Linear time complexity",
      "Quadratic time complexity",
      "Logarithmic time complexity"
    ],
    "answer": "Linear time complexity"
  },
  {
    "id": 552,
    "topic": "General",
    "question": "79. Which statement is true about the \"Big O notation\" in asymptotic analysis?",
    "options": [
      "It provides an exact measure of the algorithm's execution time.",
      "It represents the average-case time complexity of the algorithm.",
      "It gives a lower bound on the algorithm's time complexity.",
      "It helps analyze how the algorithm's performance scales with the input size."
    ],
    "answer": "It helps analyze how the algorithm's performance scales with the input size."
  },
  {
    "id": 553,
    "topic": "General",
    "question": "80. The \"Big O notation\" O(1) indicates an algorithm with:",
    "options": [
      "Constant time complexity",
      "Linear time complexity",
      "Quadratic time complexity",
      "Exponential time complexity"
    ],
    "answer": "Constant time complexity"
  },
  {
    "id": 554,
    "topic": "General",
    "question": "**9.5.2 Algorithm Analysis** 81. Algorithm analysis involves determining the:",
    "options": [
      "Exact number of steps an algorithm takes to complete",
      "Maximum number of steps an algorithm takes to complete",
      "Average number of steps an algorithm takes to complete",
      "Minimum number of steps an algorithm takes to complete"
    ],
    "answer": "Maximum number of steps an algorithm takes to complete"
  },
  {
    "id": 555,
    "topic": "General",
    "question": "82. In algorithm analysis, the term \"average-case analysis\" considers the algorithm's performance based on:",
    "options": [
      "The best possible input",
      "The worst possible input",
      "Randomly distributed inputs",
      "All possible inputs"
    ],
    "answer": "Randomly distributed inputs"
  },
  {
    "id": 556,
    "topic": "General",
    "question": "83. Which statement is true about the \"worst-case analysis\" of an algorithm?",
    "options": [
      "It provides an average measure of the algorithm's execution time.",
      "It considers the best possible input for the algorithm.",
      "It gives a lower bound on the algorithm's time complexity.",
      "It helps analyze how the algorithm performs on the least favorable input."
    ],
    "answer": "It helps analyze how the algorithm performs on the least favorable input."
  },
  {
    "id": 557,
    "topic": "General",
    "question": "84. The time complexity of an algorithm is usually expressed using:",
    "options": [
      "Exact number of steps the algorithm takes to execute",
      "Best-case analysis",
      "The \"Big O notation\"",
      "Random inputs for analysis"
    ],
    "answer": "The \"Big O notation\""
  },
  {
    "id": 558,
    "topic": "General",
    "question": "85. When analyzing an algorithm, we are primarily interested in its performance concerning:",
    "options": [
      "The total execution time",
      "The number of conditional statements used",
      "The maximum input size it can handle",
      "How the execution time grows with the input size"
    ],
    "answer": "How the execution time grows with the input size"
  },
  {
    "id": 559,
    "topic": "General",
    "question": "**9.6 Analysis of different types of Algorithms** **9.6.1 Divide and Conquer Algorithm** 86. The \"Divide and Conquer\" algorithm technique is based on the principle of:",
    "options": [
      "Iterative problem-solving",
      "Exploring all possible solutions simultaneously",
      "Breaking a problem into smaller subproblems and solving them independently",
      "Reducing the problem size by increasing the input size"
    ],
    "answer": "Breaking a problem into smaller subproblems and solving them independently"
  },
  {
    "id": 560,
    "topic": "General",
    "question": "87. The \"Merge Sort\" algorithm is an example of which technique?",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Dynamic Programming algorithm",
      "Brute force algorithm"
    ],
    "answer": "Divide and Conquer algorithm"
  },
  {
    "id": 561,
    "topic": "General",
    "question": "88. Which of the following best describes the \"Divide and Conquer\" algorithm?",
    "options": [
      "It divides the problem into overlapping subproblems and combines their solutions.",
      "It recursively breaks the problem into smaller independent subproblems.",
      "It uses random choices to explore the solution space.",
      "It uses a single approach to solve problems of different sizes."
    ],
    "answer": "It recursively breaks the problem into smaller independent subproblems."
  },
  {
    "id": 562,
    "topic": "General",
    "question": "89. A Divide and Conquer algorithm reduces the problem size by:",
    "options": [
      "Increasing the input size",
      "Combining all subproblems into one",
      "Dividing the problem into subproblems of equal size",
      "Ignoring subproblems that do not contribute to the final solution"
    ],
    "answer": "Dividing the problem into subproblems of equal size"
  },
  {
    "id": 563,
    "topic": "General",
    "question": "90. Merge Sort has a time complexity of O(n log n). What does this mean?",
    "options": [
      "The algorithm always performs n log n operations.",
      "The algorithm is most efficient for small input sizes.",
      "The algorithm's performance grows at a linear rate with the input size.",
      "The algorithm's performance grows at a logarithmic rate with the input size."
    ],
    "answer": "The algorithm's performance grows at a linear rate with the input size."
  },
  {
    "id": 564,
    "topic": "General",
    "question": "**9.6.2 Greedy algorithm** 91. Greedy algorithms make decisions based on:",
    "options": [
      "Random choices",
      "The optimal choice at each step",
      "The minimum possible solution",
      "The maximum possible solution"
    ],
    "answer": "The optimal choice at each step"
  },
  {
    "id": 565,
    "topic": "General",
    "question": "92. The \"Knapsack Problem\" is a classic example of a problem solved using which technique?",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Dynamic Programming algorithm",
      "Brute force algorithm"
    ],
    "answer": "Greedy algorithm"
  },
  {
    "id": 566,
    "topic": "General",
    "question": "93. Which statement is true about greedy algorithms?",
    "options": [
      "Greedy algorithms always guarantee the global optimum for all problems.",
      "Greedy algorithms are usually more time-efficient than other algorithm classes.",
      "Greedy algorithms can sometimes lead to suboptimal solutions for some problems.",
      "Greedy algorithms are only applicable to problems with a small number of variables."
    ],
    "answer": "Greedy algorithms can sometimes lead to suboptimal solutions for some problems."
  },
  {
    "id": 567,
    "topic": "General",
    "question": "94. The \"Huffman Coding\" algorithm uses a greedy approach to:",
    "options": [
      "Find the shortest path in a graph",
      "Optimize the use of memory in data compression",
      "Divide a problem into smaller subproblems",
      "Find the optimal solution to a linear programming problem"
    ],
    "answer": "Optimize the use of memory in data compression"
  },
  {
    "id": 568,
    "topic": "General",
    "question": "95. Greedy algorithms are particularly suitable for problems where:",
    "options": [
      "The optimal solution can be found by combining solutions to subproblems",
      "The problem can be divided into overlapping subproblems",
      "The optimal solution can be reached by making locally optimal choices at each step",
      "The problem can be solved iteratively through backtracking"
    ],
    "answer": "The optimal solution can be reached by making locally optimal choices at each step"
  },
  {
    "id": 569,
    "topic": "General",
    "question": "**9.6.3 Dynamic Programming algorithm** 96. Dynamic Programming algorithms are particularly useful for solving problems that exhibit:",
    "options": [
      "Overlapping subproblems and optimal substructure",
      "Low complexity and small input size",
      "Independent subproblems and no overlapping",
      "Linear data structures and one-dimensional arrays"
    ],
    "answer": "Overlapping subproblems and optimal substructure"
  },
  {
    "id": 570,
    "topic": "General",
    "question": "97. The \"Fibonacci sequence\" is a classic problem solved using which technique?",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Dynamic Programming algorithm",
      "Brute force algorithm"
    ],
    "answer": "Dynamic Programming algorithm"
  },
  {
    "id": 571,
    "topic": "General",
    "question": "98. Which statement best describes the dynamic programming technique?",
    "options": [
      "It explores all possible solutions simultaneously to find the optimal one.",
      "It divides the problem into smaller independent subproblems.",
      "It uses a greedy approach to find the global optimum.",
      "It solves subproblems recursively and stores their solutions to avoid redundant computations."
    ],
    "answer": "It solves subproblems recursively and stores their solutions to avoid redundant computations."
  },
  {
    "id": 572,
    "topic": "General",
    "question": "computations. 99. In the context of dynamic programming, the term \"memoization\" refers to:",
    "options": [
      "Storing data in one-dimensional arrays",
      "Storing intermediate results to avoid redundant calculations",
      "Solving the problem iteratively using a bottom-up approach",
      "Using a divide and conquer approach to solve subproblems"
    ],
    "answer": "Storing intermediate results to avoid redundant calculations"
  },
  {
    "id": 573,
    "topic": "General",
    "question": "100. Dynamic Programming is more suitable for problems that have:",
    "options": [
      "A small number of variables",
      "Subproblems with overlapping solutions",
      "Randomly distributed inputs",
      "A fixed set of possible solutions"
    ],
    "answer": "Subproblems with overlapping solutions"
  },
  {
    "id": 574,
    "topic": "General",
    "question": "**9.6.4 Brute force algorithm** 101. Brute force algorithms:",
    "options": [
      "Always guarantee the optimal solution",
      "Are the most efficient for large-scale problems",
      "Examine all possible solutions and select the best one",
      "Are suitable only for problems with a small number of variables"
    ],
    "answer": "Examine all possible solutions and select the best one"
  },
  {
    "id": 575,
    "topic": "General",
    "question": "102. Which statement best describes the brute force algorithm?",
    "options": [
      "It breaks a problem into smaller subproblems and solves each independently.",
      "It always guarantees the optimal solution for all problems.",
      "It uses random choices to explore the solution space.",
      "It explores all possible solutions to find the best one."
    ],
    "answer": "It explores all possible solutions to find the best one."
  },
  {
    "id": 576,
    "topic": "General",
    "question": "103. Brute force algorithms are most appropriate for problems where:",
    "options": [
      "The optimal solution can be found by combining solutions to subproblems",
      "The problem can be divided into smaller independent subproblems",
      "The problem size is small, and all possible solutions can be checked",
      "The problem involves dynamic programming and memoization"
    ],
    "answer": "The problem size is small, and all possible solutions can be checked"
  },
  {
    "id": 577,
    "topic": "General",
    "question": "104. The main drawback of using brute force algorithms is that they:",
    "options": [
      "Require sophisticated data structures",
      "Are not suitable for problems with overlapping subproblems",
      "Have high time and space complexity for large input sizes",
      "Are only applicable to problems with a small number of variables"
    ],
    "answer": "Have high time and space complexity for large input sizes"
  },
  {
    "id": 578,
    "topic": "General",
    "question": "105. The \"Traveling Salesman Problem\" is an example of a problem often solved using which technique?",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Dynamic Programming algorithm",
      "Brute force algorithm"
    ],
    "answer": "Brute force algorithm"
  },
  {
    "id": 579,
    "topic": "General",
    "question": "**9.6.5 Backtracking algorithms** 106. Backtracking algorithms are used to solve problems that involve:",
    "options": [
      "Finding the shortest path in a graph",
      "Searching for an element in a sorted array",
      "Exploring all possible solutions and making choices along the way",
      "Dividing the problem into two smaller subproblems"
    ],
    "answer": "Exploring all possible solutions and making choices along the way"
  },
  {
    "id": 580,
    "topic": "General",
    "question": "107. The \"N-Queens Problem\" is an example of a problem often solved using which technique?",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Dynamic Programming algorithm",
      "Backtracking algorithm"
    ],
    "answer": "Backtracking algorithm"
  },
  {
    "id": 581,
    "topic": "General",
    "question": "108. Backtracking is most suitable for problems where:",
    "options": [
      "The optimal solution can be found by combining solutions to subproblems",
      "The problem can be divided into smaller independent subproblems",
      "The problem involves exploring all possible solutions and making choices",
      "The problem can be solved iteratively using dynamic programming"
    ],
    "answer": "The problem involves exploring all possible solutions and making choices"
  },
  {
    "id": 582,
    "topic": "General",
    "question": "109. The main advantage of using backtracking algorithms is that they:",
    "options": [
      "Always guarantee the optimal solution",
      "Have low time complexity for large input sizes",
      "Can solve problems with overlapping subproblems",
      "Explore only a subset of possible solutions"
    ],
    "answer": "Explore only a subset of possible solutions"
  },
  {
    "id": 583,
    "topic": "General",
    "question": "110. Which statement is true about backtracking algorithms?",
    "options": [
      "Backtracking algorithms are primarily used for sorting problems.",
      "Backtracking always finds the optimal solution to any problem.",
      "Backtracking uses a greedy approach to explore the solution space.",
      "Backtracking is a form of recursion that explores all possible paths until a solution is found."
    ],
    "answer": "Backtracking is a form of recursion that explores all possible paths until a solution is found."
  },
  {
    "id": 584,
    "topic": "General",
    "question": "**9.6.6 Branch-and-bound algorithms** 111. Branch-and-bound algorithms:",
    "options": [
      "Always guarantee the optimal solution",
      "Are the most efficient for large-scale problems",
      "Divide the problem into smaller subproblems",
      "Explore only a subset of possible solutions while eliminating suboptimal paths"
    ],
    "answer": "Explore only a subset of possible solutions while eliminating suboptimal paths"
  },
  {
    "id": 585,
    "topic": "General",
    "question": "112. Which statement best describes branch-and-bound algorithms?",
    "options": [
      "They solve subproblems independently and combine their solutions.",
      "They use a greedy approach to explore the solution space.",
      "They explore all possible solutions to find the best one.",
      "They eliminate suboptimal paths during the search."
    ],
    "answer": "They eliminate suboptimal paths during the search."
  },
  {
    "id": 586,
    "topic": "General",
    "question": "113. Branch-and-bound algorithms are most appropriate for problems where:",
    "options": [
      "The optimal solution can be found by combining solutions to subproblems",
      "The problem can be divided into smaller independent subproblems",
      "The problem involves exploring all possible solutions and making choices",
      "The problem involves finding the shortest path in a graph"
    ],
    "answer": "The problem involves finding the shortest path in a graph"
  },
  {
    "id": 587,
    "topic": "General",
    "question": "114. The \"Traveling Salesman Problem\" can also be solved using branch-and-bound algorithms. What is the main benefit of using this technique?",
    "options": [
      "It guarantees the optimal solution in all cases.",
      "It explores all possible solutions in a short amount of time.",
      "It significantly reduces the time complexity compared to other techniques.",
      "It prunes suboptimal paths and eliminates redundant computations."
    ],
    "answer": "It prunes suboptimal paths and eliminates redundant computations."
  },
  {
    "id": 588,
    "topic": "General",
    "question": "115. The main drawback of using branch-and-bound algorithms is that they:",
    "options": [
      "Are computationally expensive for large-scale problems",
      "Require a large amount of memory to store intermediate results",
      "Cannot handle problems with overlapping subproblems",
      "Only work for problems with a small number of variables"
    ],
    "answer": "Are computationally expensive for large-scale problems"
  },
  {
    "id": 589,
    "topic": "General",
    "question": "**9.6.7 Stochastic algorithms** 116. Stochastic algorithms are used to solve problems that involve:",
    "options": [
      "Finding the shortest path in a graph",
      "Exploring all possible solutions and making choices along the way",
      "Random choices and probability distributions",
      "Solving problems with overlapping subproblems"
    ],
    "answer": "Random choices and probability distributions"
  },
  {
    "id": 590,
    "topic": "General",
    "question": "117. The \"Simulated Annealing\" algorithm is an example of a problem solved using which technique?",
    "options": [
      "Divide and Conquer algorithm",
      "Greedy algorithm",
      "Stochastic algorithm",
      "Brute force algorithm"
    ],
    "answer": "Stochastic algorithm"
  },
  {
    "id": 591,
    "topic": "General",
    "question": "118. Stochastic algorithms are most suitable for problems where:",
    "options": [
      "The optimal solution can be found by combining solutions to subproblems",
      "The problem can be divided into smaller independent subproblems",
      "The problem involves exploring all possible solutions and making choices",
      "The problem can benefit from random exploration and probabilistic selection"
    ],
    "answer": "The problem can benefit from random exploration and probabilistic selection"
  },
  {
    "id": 592,
    "topic": "General",
    "question": "119. The main advantage of using stochastic algorithms is that they:",
    "options": [
      "Always guarantee the optimal solution",
      "Have low time complexity for large input sizes",
      "Can solve problems with overlapping subproblems",
      "Introduce randomness, which can lead to better solutions in some cases"
    ],
    "answer": "Introduce randomness, which can lead to better solutions in some cases"
  },
  {
    "id": 593,
    "topic": "General",
    "question": "120. Which statement is true about stochastic algorithms?",
    "options": [
      "Stochastic algorithms are less effective than other techniques for solving optimization problems.",
      "Stochastic algorithms use a deterministic approach to explore the solution space.",
      "Stochastic algorithms are primarily used for sorting problems.",
      "Stochastic algorithms use random choices and probability distributions to search for solutions."
    ],
    "answer": "Stochastic algorithms use random choices and probability distributions to search for solutions."
  },
  {
    "id": 594,
    "topic": "General",
    "question": "solutions. **9.7 Complexity** **9.7.1 Complexity Analysis** 121. Complexity analysis of an algorithm involves:",
    "options": [
      "Determining the average execution time for all inputs",
      "Estimating the best-case execution time for a given input",
      "Analyzing the algorithm's performance as the input size increases",
      "Measuring the total number of steps the algorithm takes to complete"
    ],
    "answer": "Analyzing the algorithm's performance as the input size increases"
  },
  {
    "id": 595,
    "topic": "General",
    "question": "122. Which statement is true about the \"space complexity\" of an algorithm?",
    "options": [
      "It measures the maximum number of recursive calls in the algorithm.",
      "It represents the amount of memory used by the algorithm to store data.",
      "It gives a lower bound on the algorithm's time complexity.",
      "It helps analyze how the algorithm's performance scales with the input size."
    ],
    "answer": "It represents the amount of memory used by the algorithm to store data."
  },
  {
    "id": 596,
    "topic": "General",
    "question": "123. The \"space complexity\" of an algorithm is usually expressed using:",
    "options": [
      "The total number of steps the algorithm takes to execute",
      "The \"Big O notation\"",
      "The maximum amount of memory used by the algorithm",
      "The best-case execution time for a given input"
    ],
    "answer": "The maximum amount of memory used by the algorithm"
  },
  {
    "id": 597,
    "topic": "General",
    "question": "124. The \"time complexity\" of an algorithm is a measure of:",
    "options": [
      "The maximum number of recursive calls in the algorithm",
      "The amount of memory used by the algorithm to store data",
      "The number of conditional statements in the algorithm",
      "The total number of steps the algorithm takes to complete"
    ],
    "answer": "The total number of steps the algorithm takes to complete"
  },
  {
    "id": 598,
    "topic": "General",
    "question": "125. In time complexity analysis, the term \"Big O notation\" is used to represent the:",
    "options": [
      "Best-case time complexity of the algorithm",
      "Average-case time complexity of the algorithm",
      "Worst-case time complexity of the algorithm",
      "Space complexity of the algorithm"
    ],
    "answer": "Worst-case time complexity of the algorithm"
  },
  {
    "id": 599,
    "topic": "General",
    "question": "**9.7.2 Space complexity of the algorithm** 126. The space complexity of an algorithm is determined by:",
    "options": [
      "The maximum number of recursive calls in the algorithm",
      "The total number of steps the algorithm takes to complete",
      "The amount of memory used by the algorithm to store data",
      "The number of conditional statements in the algorithm"
    ],
    "answer": "The amount of memory used by the algorithm to store data"
  },
  {
    "id": 600,
    "topic": "General",
    "question": "127. The space complexity of an algorithm is usually expressed using:",
    "options": [
      "The total number of steps the algorithm takes to execute",
      "The \"Big O notation\"",
      "The maximum amount of memory used by the algorithm",
      "The best-case execution time for a given input"
    ],
    "answer": "The maximum amount of memory used by the algorithm"
  },
  {
    "id": 601,
    "topic": "General",
    "question": "128. The space complexity of an algorithm is important to consider when:",
    "options": [
      "The algorithm contains a large number of conditional statements",
      "The input size is small",
      "The algorithm is implemented using recursive function calls",
      "The algorithm has a small number of variables"
    ],
    "answer": "The algorithm is implemented using recursive function calls"
  },
  {
    "id": 602,
    "topic": "General",
    "question": "129. Which statement is true about space complexity analysis?",
    "options": [
      "Space complexity measures the average memory used by the algorithm.",
      "Space complexity analysis is only applicable to algorithms with low time complexity.",
      "Space complexity is independent of the input size.",
      "Space complexity helps determine how much memory an algorithm needs to execute."
    ],
    "answer": "Space complexity helps determine how much memory an algorithm needs to execute."
  },
  {
    "id": 603,
    "topic": "General",
    "question": "130. The \"space complexity\" of an algorithm can be reduced by:",
    "options": [
      "Adding more variables to store intermediate results",
      "Using recursion to solve subproblems",
      "Employing data structures with high memory overhead",
      "Avoiding redundant data storage"
    ],
    "answer": "Avoiding redundant data storage"
  },
  {
    "id": 604,
    "topic": "General",
    "question": "**9.7.3 Time complexity of the algorithm** 131. The time complexity of an algorithm is determined by:",
    "options": [
      "The maximum number of recursive calls in the algorithm",
      "The amount of memory used by the algorithm to store data",
      "The number of conditional statements in the algorithm",
      "The total number of steps the algorithm takes to complete"
    ],
    "answer": "The total number of steps the algorithm takes to complete"
  },
  {
    "id": 605,
    "topic": "General",
    "question": "132. The time complexity of an algorithm is usually expressed using:",
    "options": [
      "The total number of steps the algorithm takes to execute",
      "The \"Big O notation\"",
      "The maximum amount of memory used by the algorithm",
      "The best-case execution time for a given input"
    ],
    "answer": "The \"Big O notation\""
  },
  {
    "id": 606,
    "topic": "General",
    "question": "133. The time complexity of an algorithm is important to consider when:",
    "options": [
      "The algorithm contains a large number of conditional statements",
      "The input size is small",
      "The algorithm is implemented using recursive function calls",
      "The algorithm has a small number of variables"
    ],
    "answer": "The algorithm contains a large number of conditional statements"
  },
  {
    "id": 607,
    "topic": "General",
    "question": "134. Which statement is true about time complexity analysis?",
    "options": [
      "Time complexity measures the average execution time of the algorithm.",
      "Time complexity analysis is only applicable to algorithms with high space complexity.",
      "Time complexity is independent of the input size.",
      "Time complexity helps determine the efficiency of an algorithm concerning the input size."
    ],
    "answer": "Time complexity helps determine the efficiency of an algorithm concerning the input size."
  },
  {
    "id": 608,
    "topic": "General",
    "question": "135. The \"time complexity\" of an algorithm can be reduced by:",
    "options": [
      "Increasing the number of conditional statements in the algorithm",
      "Using recursion to solve subproblems",
      "Employing data structures with low time overhead",
      "Optimizing the algorithm to minimize the number of steps"
    ],
    "answer": "Optimizing the algorithm to minimize the number of steps"
  },
  {
    "id": 609,
    "topic": "General",
    "question": "**9.8 Case study on Algorithm Design techniques** 136. A case study on algorithm design techniques involves:",
    "options": [
      "Analyzing the space and time complexity of an algorithm",
      "Comparing the efficiency of different algorithm classes",
      "Applying different algorithms to a specific problem and evaluating their performance",
      "Identifying the optimal solution to a given problem"
    ],
    "answer": "Applying different algorithms to a specific problem and evaluating their performance"
  },
  {
    "id": 610,
    "topic": "General",
    "question": "137. In a case study on algorithm design techniques, the goal is to:",
    "options": [
      "Prove the correctness of a particular algorithm",
      "Determine the best algorithm class for a given problem",
      "Find the most efficient algorithm for all input sizes",
      "Test the algorithm's performance under various conditions"
    ],
    "answer": "Determine the best algorithm class for a given problem"
  },
  {
    "id": 611,
    "topic": "General",
    "question": "138. The main purpose of conducting a case study on algorithm design techniques is to:",
    "options": [
      "Identify the best algorithm for a specific problem",
      "Determine the average execution time of an algorithm",
      "Explore different data structures used in algorithms",
      "Analyze the space complexity of an algorithm"
    ],
    "answer": "Identify the best algorithm for a specific problem"
  },
  {
    "id": 612,
    "topic": "General",
    "question": "139. Which statement is true about a case study on algorithm design techniques?",
    "options": [
      "The case study involves comparing algorithms based on their code complexity.",
      "The case study helps determine the most optimal solution for any given problem.",
      "The case study focuses on finding the average execution time of an algorithm.",
      "The case study evaluates algorithm performance using real-world scenarios."
    ],
    "answer": "The case study evaluates algorithm performance using real-world scenarios."
  },
  {
    "id": 613,
    "topic": "General",
    "question": "140. The results of a case study on algorithm design techniques can be used to:",
    "options": [
      "Prove the correctness of a particular algorithm",
      "Determine the best algorithm for a specific problem under certain conditions",
      "Establish the average execution time of an algorithm",
      "Explore the mathematical properties of different algorithms"
    ],
    "answer": "Determine the best algorithm for a specific problem under certain conditions"
  },
  {
    "id": 614,
    "topic": "General",
    "question": "**9.9 Application of Data structures** 141. Data structures are used in algorithm design to:",
    "options": [
      "Optimize the space complexity of an algorithm",
      "Improve the readability of algorithm code",
      "Store and organize data efficiently during algorithm execution",
      "Reduce the number of steps an algorithm takes to complete"
    ],
    "answer": "Store and organize data efficiently during algorithm execution"
  },
  {
    "id": 615,
    "topic": "General",
    "question": "142. The primary purpose of using data structures in algorithm design is to:",
    "options": [
      "Reduce the time complexity of the algorithm",
      "Provide a visual representation of the algorithm's execution",
      "Optimize the algorithm's performance for large input sizes",
      "Facilitate the storage and retrieval of data during algorithm execution"
    ],
    "answer": "Facilitate the storage and retrieval of data during algorithm execution"
  },
  {
    "id": 616,
    "topic": "General",
    "question": "143. Which statement best describes the relationship between data structures and algorithms?",
    "options": [
      "Data structures represent the steps in an algorithm's execution.",
      "Data structures are the algorithms used to process data.",
      "Data structures and algorithms are separate entities with no connection.",
      "Data structures provide the foundation for algorithm design and execution."
    ],
    "answer": "Data structures provide the foundation for algorithm design and execution."
  },
  {
    "id": 617,
    "topic": "General",
    "question": "144. The choice of data structure in algorithm design is influenced by:",
    "options": [
      "The programming language used to implement the algorithm",
      "The availability of built-in data structures in the programming language",
      "The input size and the specific operations required by the algorithm",
      "The level of code complexity in the algorithm"
    ],
    "answer": "The input size and the specific operations required by the algorithm"
  },
  {
    "id": 618,
    "topic": "General",
    "question": "145. Data structures used in algorithm design can include:",
    "options": [
      "All types of conditional statements used in the algorithm",
      "Arrays and loops for repetitive tasks",
      "Mathematical formulas for efficient calculations",
      "Lists, queues, stacks, and trees to store and organize data"
    ],
    "answer": "Lists, queues, stacks, and trees to store and organize data"
  }
]